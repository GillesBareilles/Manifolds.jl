var documenterSearchIndex = {"docs":
[{"location":"index.html#Manifolds-1","page":"Home","title":"Manifolds","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Package Manifolds aims to provide both a unified interface to define and use manifolds as well as a library of manifolds to use for your projects.","category":"page"},{"location":"index.html#Interface-1","page":"Home","title":"Interface","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Modules = [Manifolds]\nPages = [\"Manifolds.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"index.html#Manifolds.IsDecoratorManifold","page":"Home","title":"Manifolds.IsDecoratorManifold","text":"IsDecoratorManifold\n\nA Trait to mark a manifold as a decorator type. For any function that is only implemented for a decorator (i.e. a Manifold with @traitimpl IsDecoratorManifold{M}), a specific function should be implemented as a @traitfn, that transparently passes down through decorators, i.e.\n\n@traitfn my_feature(M::MT, k...) where {MT; IsDecoratorManifold{MT}} = my_feature(M.manifold, k...)\n\nor the shorter version\n\n@traitfn my_feature(M::::IsDecoratorManifold, k...) = my_feature(M.manifold, k...)\n\nsuch that decorators act just as pass throughs for other decorator functions and\n\nmy_feature(M::MyManifold, k...) = #... my explicit implementation\n\nthen implements the feature itself.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.Manifold","page":"Home","title":"Manifolds.Manifold","text":"Manifold\n\nA manifold type. The Manifold is used to dispatch to different exponential and logarithmic maps as well as other function on manifold.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Base.exp-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}","page":"Home","title":"Base.exp","text":"exp(M::Manifold, x, v, T::AbstractVector)\n\nExponential map of tangent vector t*v at point x from manifold M for each t in T.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.exp-Tuple{Manifold,Any,Any}","page":"Home","title":"Base.exp","text":"exp(M::Manifold, x, v, t=1)\n\nExponential map of tangent vector t*v at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.isapprox-Tuple{Manifold,Any,Any,Any}","page":"Home","title":"Base.isapprox","text":"isapprox(M::Manifold, x, v, w; kwargs...)\n\nCheck if vectors v and w tangent at x from manifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Base.isapprox-Tuple{Manifold,Any,Any}","page":"Home","title":"Base.isapprox","text":"isapprox(M::Manifold, x, y; kwargs...)\n\nCheck if points x and y from manifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"index.html#LinearAlgebra.norm-Tuple{Manifold,Any,Any}","page":"Home","title":"LinearAlgebra.norm","text":"norm(M::Manifold, x, v)\n\nNorm of tangent vector v at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.base_manifold","page":"Home","title":"Manifolds.base_manifold","text":"base_manifold(M::Manifold)\n\nStrip all decorators on M, returning the underlying topological manifold. Also used for vector bundles.\n\n\n\n\n\n","category":"function"},{"location":"index.html#Manifolds.distance-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.distance","text":"distance(M::Manifold, x, y)\n\nShortest distance between the points x and y on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.exp!-Tuple{Manifold,Any,Any,Any,Real}","page":"Home","title":"Manifolds.exp!","text":"exp!(M::Manifold, y, x, v, t=1)\n\nExponential map of tangent vector t*v at point x from manifold M. Result is saved to y.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}","page":"Home","title":"Manifolds.geodesic","text":"geodesic(M::Manifold, x, v, T::AbstractVector)\n\nGet the points for each t in T traveling from x along the geodesic with initial point x and velocity v.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.geodesic-Tuple{Manifold,Any,Any,Real}","page":"Home","title":"Manifolds.geodesic","text":"geodesic(M::Manifold, x, v, t)\n\nGet the point at time t traveling from x along the geodesic with initial point x and velocity v.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.geodesic-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.geodesic","text":"geodesic(M::Manifold, x, v)\n\nGet the geodesic with initial point x and velocity v. The geodesic is the curve of constant velocity that is locally distance-minimizing. This function returns a function of time, which may be a Real or an AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.injectivity_radius-Tuple{Manifold,Any,Manifolds.AbstractRetractionMethod}","page":"Home","title":"Manifolds.injectivity_radius","text":"injectivity_radius(M::Manifold, x, R::AbstractRetractionMethod)\n\nDistance d such that retract(M, x, v, R) is injective for all tangent vectors shorter than d (has a left inverse).\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.injectivity_radius-Tuple{Manifold,Any}","page":"Home","title":"Manifolds.injectivity_radius","text":"injectivity_radius(M::Manifold, x)\n\nDistance d such that exp(M, x, v) is injective for all tangent vectors shorter than d (has a left inverse).\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.injectivity_radius-Tuple{Manifold}","page":"Home","title":"Manifolds.injectivity_radius","text":"injectivity_radius(M::Manifold, x)\n\nInfimum of the injectivity radii of all manifold points.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.inner-Tuple{Manifold,Any,Any,Any}","page":"Home","title":"Manifolds.inner","text":"inner(M::Manifold, x, v, w)\n\nInner product of tangent vectors v and w at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.inverse_retract!-Tuple{Manifold,Any,Any,Any,Manifolds.LogarithmicInverseRetraction}","page":"Home","title":"Manifolds.inverse_retract!","text":"inverse_retract!(M::Manifold, v, x, y, [method::AbstractInverseRetractionMethod=LogarithmicInverseRetraction()])\n\nInverse retraction (cheaper, approximate version of logarithmic map) of points x and y. Result is saved to y.\n\nInverse retraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.inverse_retract-Tuple{Manifold,Any,Any,Manifolds.AbstractInverseRetractionMethod}","page":"Home","title":"Manifolds.inverse_retract","text":"inverse_retract(M::Manifold, x, y, [method::AbstractInverseRetractionMethod])\n\nInverse retraction (cheaper, approximate version of logarithmic map) of points x and y from manifold M.\n\nInverse retraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.is_manifold_point-Tuple{Manifold,Any}","page":"Home","title":"Manifolds.is_manifold_point","text":"is_manifold_point(M,x)\n\ncheck, whether x is a valid point on the Manifold M. If it is not, an error is thrown. The default is to return true, i.e. if no checks are implmented, the assumption is to be optimistic.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.is_tangent_vector-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.is_tangent_vector","text":"is_tangent_vector(M,x,v)\n\ncheck, whether v is a valid tangnt vector in the tangent plane of x on the Manifold M. An implementation should first check is_manifold_point(M,x) and then validate v. If it is not a tangent vector an error should be thrown. The default is to return true, i.e. if no checks are implmented, the assumption is to be optimistic.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.manifold_dimension","page":"Home","title":"Manifolds.manifold_dimension","text":"manifold_dimension(M::Manifold)\n\nThe dimension n of real space mathbb R^n to which the neighborhood of each point of the manifold is homeomorphic.\n\n\n\n","category":"function"},{"location":"index.html#Manifolds.project_point!-Tuple{Manifold,Any}","page":"Home","title":"Manifolds.project_point!","text":"project_point!(M::Manifold, x)\n\nProject point from the ambient space onto the manifold M. The point x is modified. The function works only for selected embedded manifolds and is not required to return the closest point.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.project_point-Tuple{Manifold,Any}","page":"Home","title":"Manifolds.project_point","text":"project_point(M::Manifold, x)\n\nProject point from the ambient space onto the manifold M. The point x is not modified. The function works only for selected embedded manifolds and is not required to return the closest point.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.project_tangent!-Tuple{Manifold,Any,Any,Any}","page":"Home","title":"Manifolds.project_tangent!","text":"project_tangent!(M::Manifold, w, x, v)\n\nProject ambient space representation of a vector v to a tangent vector at point x from the manifold M. The result is saved in vector w.\n\nThe function works only for selected embedded manifolds and is not required to return the closest vector.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.project_tangent-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.project_tangent","text":"project_tangent(M::Manifold, x, v)\n\nProject ambient space representation of a vector v to a tangent vector at point x from the manifold M.\n\nThe function works only for selected embedded manifolds and is not required to return the closest vector.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.retract!-Tuple{Manifold,Any,Any,Any,Manifolds.ExponentialRetraction}","page":"Home","title":"Manifolds.retract!","text":"retract!(M::Manifold, y, x, v, [t=1], [method::AbstractRetractionMethod=ExponentialRetraction()])\n\nRetraction (cheaper, approximate version of exponential map) of tangent vector t*v at point x from manifold M. Result is saved to y.\n\nRetraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.retract-Tuple{Manifold,Any,Any,Manifolds.AbstractRetractionMethod}","page":"Home","title":"Manifolds.retract","text":"retract(M::Manifold, x, v, [t=1], [method::AbstractRetractionMethod])\n\nRetraction (cheaper, approximate version of exponential map) of tangent vector t*v at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}","page":"Home","title":"Manifolds.shortest_geodesic","text":"shortest_geodesic(M::Manifold, x, y, T::AbstractVector)\n\nGet the points for each t in T traveling from x along a shortest geodesic connecting x and y, where y is reached at t=1.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any,Real}","page":"Home","title":"Manifolds.shortest_geodesic","text":"shortest_geodesic(M::Manifold, x, y, t)\n\nGet the point at time t traveling from x along a shortest geodesic connecting x and y, where y is reached at t=1.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.shortest_geodesic","text":"shortest_geodesic(M::Manifold, x, y)\n\nGet a geodesic with initial point x and point y at t=1 whose length is the shortest path between the two points. When there are multiple shortest geodesics, there is no guarantee which will be returned. This function returns a function of time, which may be a Real or an AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}","page":"Home","title":"Manifolds.vector_transport_direction!","text":"vector_transport_direction!(M::Manifold, vto, x, v, vdir)\n\nVector transport of vector v at point x in the direction indicated by the tangent vector vdir at point x. The result is saved to vto. By default, exp and vector_transport_to! are used.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vector_transport_direction-Tuple{Manifold,Any,Any,Any}","page":"Home","title":"Manifolds.vector_transport_direction","text":"vector_transport_direction(M::Manifold, x, v, vdir)\n\nVector transport of vector v at point x in the direction indicated by the tangent vector vdir at point x.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}","page":"Home","title":"Manifolds.vector_transport_to!","text":"vector_transport_to!(M::Manifold, vto, x, v, y)\n\nVector transport of vector v at point x to point y. The result is saved to vto. By default, project_tangent! is used but this may change in the future.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vector_transport_to-Tuple{Manifold,Any,Any,Any}","page":"Home","title":"Manifolds.vector_transport_to","text":"vector_transport_to(M::Manifold, x, v, y)\n\nVector transport of vector v at point x to point y.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.CoTVector","page":"Home","title":"Manifolds.CoTVector","text":"CoTVector\n\nType for a cotangent vector of a manifold. While a Manifold not necessarily requires this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of cotangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.ExponentialRetraction","page":"Home","title":"Manifolds.ExponentialRetraction","text":"ExponentialRetraction\n\nRetraction using the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.LogarithmicInverseRetraction","page":"Home","title":"Manifolds.LogarithmicInverseRetraction","text":"LogarithmicInverseRetraction\n\nInverse retraction using the logarithmic map.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.MPoint","page":"Home","title":"Manifolds.MPoint","text":"MPoint\n\nType for a point on a manifold. While a Manifold not necessarily requires this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of points on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.OutOfInjectivityRadiusError","page":"Home","title":"Manifolds.OutOfInjectivityRadiusError","text":"OutOfInjectivityRadiusError\n\nAn error thrown when a function (for example logarithmic map or inverse retraction) is given arguments outside of its injectivity radius.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.TVector","page":"Home","title":"Manifolds.TVector","text":"TVector\n\nType for a tangent vector of a manifold. While a Manifold not necessarily requires this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of tangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Base.angle-Tuple{Manifold,Any,Any,Any}","page":"Home","title":"Base.angle","text":"angle(M::Manifold, x, v, w)\n\nAngle between tangent vectors v and w at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.hat-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.hat","text":"hat(M::Manifold, x, vⁱ)\n\nGiven a basis e_i on the tangent space at a point x and tangent component vector v^i, compute the equivalent vector representation v=v^i e_i, where Einstein summation notation is used:\n\nwedge v^i mapsto v^i e_i\n\nFor matrix manifolds, this converts a vector representation of the tangent vector to a matrix representation. The vee map is the hat map's inverse.\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.representation_size","page":"Home","title":"Manifolds.representation_size","text":"representation_size(M::Manifold, [VS::VectorSpaceType])\n\nThe size of array representing a point on manifold M, Representation sizes of tangent vectors can be obtained by calling the method with the second argument.\n\n\n\n","category":"function"},{"location":"index.html#Manifolds.similar_result-Tuple{Manifold,Any,Vararg{Any,N} where N}","page":"Home","title":"Manifolds.similar_result","text":"similar_result(M::Manifold, f, x...)\n\nAllocates an array for the result of function f on manifold M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\nUsefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.similar_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N","page":"Home","title":"Manifolds.similar_result_type","text":"similar_result_type(M::Manifold, f, args::NTuple{N,Any}) where N\n\nReturns type of element of the array that will represent the result of function f for manifold M on given arguments (passed at a tuple).\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}","page":"Home","title":"Manifolds.vector_transport_along!","text":"vector_transport_along!(M::Manifold, vto, x, v, c)\n\nVector transport of vector v at point x along the curve c such that c(0) is equal to x to point c(1). The result is saved to vto.\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vector_transport_along-Tuple{Manifold,Any,Any,Any}","page":"Home","title":"Manifolds.vector_transport_along","text":"vector_transport_along(M::Manifold, x, v, c)\n\nVector transport of vector v at point x along the curve c such that c(0) is equal to x to point c(1).\n\n\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vee-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.vee","text":"vee(M::Manifold, x, v)\n\nGiven a basis e_i on the tangent space at a point x and tangent vector v, compute the vector components v^i, such that v = v^i e_i, where Einstein summation notation is used:\n\nvee v^i e_i mapsto v^i\n\nFor matrix manifolds, this converts a  matrix representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n","category":"method"},{"location":"index.html#Decorators-1","page":"Home","title":"Decorators","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Array manifold\nMetric manifold","category":"page"},{"location":"index.html#Lie-Group-1","page":"Home","title":"Lie Group","text":"","category":"section"},{"location":"manifolds/euclidean.html#Sphere-1","page":"Euclidean","title":"Sphere","text":"","category":"section"},{"location":"manifolds/euclidean.html#","page":"Euclidean","title":"Euclidean","text":"Modules = [Manifolds]\nPages = [\"Euclidean.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/euclidean.html#Manifolds.Euclidean","page":"Euclidean","title":"Manifolds.Euclidean","text":"Euclidean{T<:Tuple} <: Manifold\n\nEuclidean vector space mathbb R^n.\n\nConstructor\n\nEuclidean(n)\n\ngenerates the n-dimensional vector space mathbb R^n.\n\nEuclidean(m, n)\n\ngenerates the mn-dimensional vector space mathbb R^m times n, whose elements are interpreted as m times n matrices.\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#Manifolds.normal_tvector_distribution-Union{Tuple{N}, Tuple{Euclidean{Tuple{N}},Any,Any}} where N","page":"Euclidean","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(S::Euclidean, x, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.projected_distribution-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"Manifolds.projected_distribution","text":"projected_distribution(M::Euclidean, d, [x])\n\nWraps standard distribution d into a manifold-valued distribution. Generated points will be of similar type to x. By default, the type is not changed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Rotations-1","page":"Rotations","title":"Rotations","text":"","category":"section"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"The manifold mathrmSO(n) of orthogonal matrices with determinant +1 in mathbb R^ntimes n, i.e.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"mathrmSO(n) = biglR in mathbbR^ntimes n big RR^mathrmT =\nR^mathrmTR = mathrmI_n det(R) = 1 bigr","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"mathrmSO(n) is a subgroup of the orthogonal group mathrmO(n) and also known as the special orthogonal group or the set of rotations group.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Tangent vectors are represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Let L_Rcolon mathrmSO(n) to mathrmSO(n) where R in mathrmSO(n) be the left-multiplication by R, that is L_R(S) = RS. The tangent space at rotation R, T_R mathrmSO(n), is related to the tangent space at the identity rotation mathrmI_n by the differential of L_R at identity, (mathrmdL_R)_mathrmI_n colon T_mathrmI_n mathrmSO(n) to T_R mathrmSO(n). For a tangent vector at the identity rotation v in T_mathrmI_n mathrmSO(n) the matrix representation of the corresponding tangent vector w at a rotation R can be obtained by matrix multiplication: w=Rv in T_R mathrmSO(n). You can compare the functions log!(::Manifolds.Rotations, v, x, y) and exp!(::Manifolds.Rotations, y, x, v) to see how it works in practice.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Modules = [Manifolds]\nPages = [\"Rotations.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/rotations.html#Manifolds.exp!-Tuple{Manifolds.Rotations{4},Any,Any,Any}","page":"Rotations","title":"Manifolds.exp!","text":"exp!(M::Rotations{4}, y, x, v)\n\nExponential map of tangent vector v at point x from mathrmSO(4) manifold M. Result is saved to y.\n\nThe algorithm used is a more numerically stable form of those proposed in [Gallier, 2003] and [Andrica, 2013].\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.inner-Tuple{Manifolds.Rotations,Any,Any,Any}","page":"Rotations","title":"Manifolds.inner","text":"inner(M, x, w, v)\n\ncompute the inner product of the two tangent vectors w, v from the tangent plane at x on the special orthogonal space M=mathrmSO(n) using the restriction of the metric from the embedding, i.e.\n\n(v w)_x = operatornametr(v^T w)\n\n.\n\nTangent vectors are represented by matrices.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.inverse_retract!-Tuple{Manifolds.Rotations,Any,Any,Any,Manifolds.PolarInverseRetraction}","page":"Rotations","title":"Manifolds.inverse_retract!","text":"inverse_retract!(M, v, x, y, ::PolarInverseRetraction)\n\nCompute a vector from the tagent space T_xmathrmSO(n) of the point x on the Rotations manifold M with which the point y can be reached by the PolarRetraction from the point x after time 1.\n\nThe formula reads v = -frac12(x^mathrmTys - (x^mathrmTys)^mathrmT)\n\nwhere s is the solution to the Sylvester equation\n\nx^mathrmTys + s(x^mathrmTy)^mathrmT + 2mathrmI_n = 0\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.inverse_retract!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any,Manifolds.QRInverseRetraction}} where N","page":"Rotations","title":"Manifolds.inverse_retract!","text":"inverse_retract!(M::Rotations, x, y, ::QRInverseRetraction)\n\nCompute a vector from the tagent space T_xmathrmSO(n) of the point x on the Rotations manifold M with which the point y can be reached by the QRRetraction from the point x after time 1.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.is_manifold_point-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any}} where N","page":"Rotations","title":"Manifolds.is_manifold_point","text":"is_manifold_point(M,x; kwargs...)\n\nchecks, whether x is a valid point on the Rotations M, i.e. is an array of size manifold_dimension(M) and represents a valid rotation. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.is_tangent_vector-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any}} where N","page":"Rotations","title":"Manifolds.is_tangent_vector","text":"is_tangent_vector(M,x,v; kwargs... )\n\nchecks whether v is a tangent vector to x on the Rotations space M, i.e. after is_manifold_point(M,x), v has to be of same dimension as x and orthogonal to x. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.log!-Tuple{Manifolds.Rotations,Any,Any,Any}","page":"Rotations","title":"Manifolds.log!","text":"log!(M::Rotations, v, x, y)\n\ncompute the logarithmic map on the Rotations manifold M=mathrmSO(n), which is given by\n\nlog_x y =\n  frac12 bigl(operatornameLog(x^mathrmTy)\n  - (operatornameLog x^mathrmTy)^mathrmT)\n\nwhere operatornameLog denotes the matrix logarithm, and save the result to v.\n\nFor antipodal rotations the function returns one of the tangent vectors that point at y.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.manifold_dimension-Union{Tuple{Manifolds.Rotations{N}}, Tuple{N}} where N","page":"Rotations","title":"Manifolds.manifold_dimension","text":"manifold_dimension(M::Rotations)\n\nreturns the dimension of the manifold mathrmSO(n), i.e. fracn(n-1)2.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.retract!-Tuple{Manifolds.Rotations,Any,Any,Any,Manifolds.PolarRetraction}","page":"Rotations","title":"Manifolds.retract!","text":"retract_polar!(M::Rotations, y, x, v, method::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction, a second-order approximation of the exponential map.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.retract!-Union{Tuple{T}, Tuple{Manifolds.Rotations,AbstractArray{T,N} where N,Any,Any,Manifolds.QRRetraction}} where T","page":"Rotations","title":"Manifolds.retract!","text":"retract!(M, y, x, v, method::QRRetraction)\n\nThis QR-based retraction is a first-order approximation of the exponential map.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.NormalRotationDistribution","page":"Rotations","title":"Manifolds.NormalRotationDistribution","text":"NormalRotationDistribution(M::Rotations, d::Distribution, x::TResult)\n\nDistribution that returns a random point on the manifold Rotations M. Random point is generated using base distribution d and the type of the result is adjusted to TResult.\n\nSee normal_rotation_distribution for details.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.PolarInverseRetraction","page":"Rotations","title":"Manifolds.PolarInverseRetraction","text":"PolarInverseRetraction\n\nInverse retraction on the rotations manifold using the polar method.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.PolarRetraction","page":"Rotations","title":"Manifolds.PolarRetraction","text":"PolarRetraction\n\nRetraction on the rotations manifold using the polar method. This SVD-based retraction is a second-order approximation of the exponential map. Let\n\nUSV = x + xv\n\nbe the singular value decomposition, then the formula reads\n\noperatornameretr_x v = UV^mathrmT\n\nRetraction is performed by the function retract!(::Rotations, y, x, v, ::PolarRetraction)\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.QRInverseRetraction","page":"Rotations","title":"Manifolds.QRInverseRetraction","text":"QRInverseRetraction\n\nInverse retraction on the rotations manifold using the QR method.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.QRRetraction","page":"Rotations","title":"Manifolds.QRRetraction","text":"QRRetraction\n\nRetraction on the rotations manifold using the QR method, a first order approximation of the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.Rotations","page":"Rotations","title":"Manifolds.Rotations","text":"Rotations{N} <: Manifold\n\nSpecial orthogonal manifold mathrmSO(n) represented by ntimes n real-valued orthogonal matrices with determinant +1.\n\nConstructor\n\nRotations(n)\n\ngenerates the mathrmSO(n) subset mathbb R^ntimes n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra of mathrmSO(4) consists of 4x4 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order (corresponding to the same ordering of angles as cos_angles_4d_rotation_matrix).\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned\ncosalpha + cosbeta = frac12 operatornametr(R)\ncosalpha + cosbeta = frac18 operatornametr(R)^2\n                           - frac116 operatornametr((R - R^T)^2) - 1\nendaligned\n\nBy convention, the returned values are sorted in increasing order. See angles_4d_skew_sym_matrix. For derivation of the above, see [Gallier, 2013].\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.hat!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any}} where N","page":"Rotations","title":"Manifolds.hat!","text":"hat!(M::Rotations, Ω, x, ω)\n\nConvert the unique tangent vector components omega at point x on rotations group mathrmSO(n) to the matrix representation Omega of the tangent vector. See vee! for the conventions used.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Real}} where N","page":"Rotations","title":"Manifolds.normal_rotation_distribution","text":"normal_rotation_distribution(M::Rotations, x, σ::Real)\n\nreturn a random point on the manifold Rotations M by generating a (Gaussian) random orthogonal matrix with determinant +1. Let\n\nQR = A\n\nbe the QR decomposition of a random matrix A, then the formula reads\n\nx = QD\n\nwhere D is a diagonal matrix with the signs of the diagonal entries of R, i.e.\n\nD_ij=begincases operatornamesgn(R_ij)  textif  i=j  0   textotherwise endcases\n\nIt can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.\n\nThe argument x is used to determine the type of returned points.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_tvector_distribution-Tuple{Manifolds.Rotations,Any,Any}","page":"Rotations","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(M::Rotations, x, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.vee!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any}} where N","page":"Rotations","title":"Manifolds.vee!","text":"vee!(M::Rotations, ω, x, Ω)\n\nExtract the unique tangent vector components omega at point x on rotations group mathrmSO(n) from the matrix representation Omega of the tangent vector.\n\nThe basis on the Lie algebra mathfrakso(n) is chosen such that for mathrmSO(2), omega=theta=Omega_21 is the angle of rotation, and for mathrmSO(3), omega = (Omega_32 Omega_13 Omega_21) = theta u is the angular velocity and axis-angle representation, where u is the unit vector along the axis of rotation.\n\nFor mathrmSO(n) where n ge 4, the additional elements of omega are omega_i (i - 3)2 + j + 1 = Omega_ij, for i in 4 n j in 1i).\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Literature-1","page":"Rotations","title":"Literature","text":"","category":"section"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"<ul>\n  <li id=\"Gallier2003\">[<a>Gallier, 2003</a>]\n    J. Gallier and D. Xu, “Computing exponentials of skew-symmetric matrices\n    and logarithms of orthogonal matrices,” <i>International Journal of\n    Robotics and Automation</i>, vol. 18, no. 1, pp. 10–20, 2003.\n  </li>\n  <li id=\"Andrica2013\">[<a>Andrica, 2013</a>]\n    D. Andrica and R.-A. Rohan, “Computing the Rodrigues coefficients of the\n    exponential map of the Lie groups of matrices,” <i>Balkan Journal of\n    Geometry and Its Applications</i>, vol. 18, no. 2, pp. 1–10, 2013.\n  </li>\n</ul>","category":"page"},{"location":"manifolds/sphere.html#Sphere-1","page":"Sphere","title":"Sphere","text":"","category":"section"},{"location":"manifolds/sphere.html#","page":"Sphere","title":"Sphere","text":"Modules = [Manifolds]\nPages = [\"Sphere.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/sphere.html#Manifolds.Sphere","page":"Sphere","title":"Manifolds.Sphere","text":"Sphere{N} <: Manifold\n\nThe unit sphere manifold mathbb S^n represented by n+1-Tuples, i.e. in by vectors in mathbb R^n+1 of unit length\n\nConstructor\n\nSphere(n)\n\ngenerates the mathbb S^nsubset mathbb R^n+1\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html#Manifolds.inner-Tuple{Sphere,Any,Any,Any}","page":"Sphere","title":"Manifolds.inner","text":"inner(S::Sphere, x, w, v)\n\ncompute the inner product of the two tangent vectors w,v from the tangent plane at x on the sphere S=mathbb S^n using the restriction of the metric from the embedding, i.e. $ (v,w)_x = v^\\mathrm{T}w $.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.is_manifold_point-Union{Tuple{N}, Tuple{Sphere{N},Any}} where N","page":"Sphere","title":"Manifolds.is_manifold_point","text":"is_manifold_point(S,x; kwargs...)\n\nchecks, whether x is a valid point on the Sphere S, i.e. is a vector of length manifold_dimension(S)+1 (approximately) of unit length. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.is_tangent_vector-Union{Tuple{N}, Tuple{Sphere{N},Any,Any}} where N","page":"Sphere","title":"Manifolds.is_tangent_vector","text":"is_tangent_vector(S,x,v; kwargs... )\n\nchecks whether v is a tangent vector to x on the Sphere S, i.e. atfer is_manifold_point(S,x), v has to be of same dimension as x and orthogonal to x. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.manifold_dimension-Union{Tuple{Sphere{N}}, Tuple{N}} where N","page":"Sphere","title":"Manifolds.manifold_dimension","text":"manifold_dimension(S::Sphere)\n\nReturn the dimension of the manifold mathbb S^n, i.e. n.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.normal_tvector_distribution-Tuple{Sphere,Any,Any}","page":"Sphere","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(S::Sphere, x, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.uniform_distribution-Tuple{Sphere,Any}","page":"Sphere","title":"Manifolds.uniform_distribution","text":"uniform_distribution(S::Sphere, x)\n\nUniform distribution on given sphere. Generated points will be of similar type to x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Product-Manifold-1","page":"Product manifold","title":"Product Manifold","text":"","category":"section"},{"location":"manifolds/product.html#","page":"Product manifold","title":"Product manifold","text":"Product manifold M = M_1 times M_2 times dots M_n of manifolds M_1 M_2 dots M_n. Points on the product manifold can be constructed using ProductRepr with canonical projections Pi_i colon M to M_i for i in 1 2 dots n provided by submanifold_component.","category":"page"},{"location":"manifolds/product.html#","page":"Product manifold","title":"Product manifold","text":"Modules = [Manifolds]\nPages = [\"ProductManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/product.html#Manifolds.ProductManifold","page":"Product manifold","title":"Manifolds.ProductManifold","text":"ProductManifold{TM<:Tuple, TRanges<:Tuple, TSizes<:Tuple} <: Manifold\n\nProduct manifold M_1 times M_2 times dots times M_n with product geometry. TRanges and TSizes statically define the relationship between representation of the product manifold and representations of point, tangent vectors and cotangent vectors of respective manifolds.\n\nConstructor\n\nProductManifold(M_1, M_2, ..., M_n)\n\ngenerates the product manifold M_1 times M_2 times dots times M_n. Alternatively, the same manifold can be contructed using the × operator: M_1 × M_2 × M_3.\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.is_manifold_point-Tuple{ProductManifold,ProductRepr}","page":"Product manifold","title":"Manifolds.is_manifold_point","text":"is_manifold_point(M::ProductManifold, x; kwargs...)\n\nCheck whether x is a valid point on the ProductManifold M.\n\nThe tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.is_tangent_vector-Tuple{ProductManifold,ProductRepr,ProductRepr}","page":"Product manifold","title":"Manifolds.is_tangent_vector","text":"is_tangent_vector(M::ProductManifold, x, v; kwargs... )\n\nCheck whether v is a tangent vector to x on the ProductManifold M, i.e. atfer is_manifold_point(M, x), and all projections to base manifolds must be respective tangent vectors.\n\nThe tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,AbstractArray{T,1} where T}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::AbstractVector)\n\nExtract the factor of the product manifold M indicated by indices in i. For example, for i equal to [1, 3] the product manifold constructed from the first and the third factor is returned.\n\nThis function is not type-stable, for better preformance use submanifold(M::ProductManifold, i::Val).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,Integer}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Integer)\n\nExtract the ith factor of the product manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,Val}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Val)\n\nExtract the factor of the product manifold M indicated by indices in i. For example, for i equal to Val((1, 3)) the product manifold constructed from the first and the third factor is returned.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.InverseProductRetraction-Tuple{Vararg{Manifolds.AbstractInverseRetractionMethod,N} where N}","page":"Product manifold","title":"Manifolds.InverseProductRetraction","text":"InverseProductRetraction(inverse_retractions::AbstractInverseRetractionMethod...)\n\nProduct inverse retraction of inverse_retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.ProductFVectorDistribution","page":"Product manifold","title":"Manifolds.ProductFVectorDistribution","text":"ProductFVectorDistribution([type::VectorBundleFibers], [x], distrs...)\n\nGenerates a random vector at point x from vector space (a fiber of a tangent bundle) of type type using the product distribution of given distributions.\n\nVector space type and x can be automatically inferred from distributions distrs.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductPointDistribution","page":"Product manifold","title":"Manifolds.ProductPointDistribution","text":"ProductPointDistribution(M::ProductManifold, distributions)\n\nProduct distribution on manifold M, combined from distributions.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductRetraction","page":"Product manifold","title":"Manifolds.ProductRetraction","text":"ProductRetraction(retractions::AbstractRetractionMethod...)\n\nProduct retraction of retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Vector-bundles-1","page":"Vector bundle","title":"Vector bundles","text":"","category":"section"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Vector bundle E is a manifold that is built on top of another manifold M (base space). It is characterized by a continuous function Pi colon E to M, such that for each point x in M the preimage of x by Pi, Pi^-1(x), has a structure of a vector space. These vector spaces are called fibers. Bundle projection can be performed using function bundle_projection.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Tangent bundle is a simple example of a vector bundle, swhere each fiber is the tangent space at the specified point x. An object representing a tangent bundle can be obtained using the constructor called TangentBundle.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Fibers of a vector bundle are represented by the type VectorBundleFibers. The important difference between functions operating on VectorBundle and VectorBundleFibers is that in the first case both a point on the underlying manifold and the vector are represented together (by a single argument) while in the second case only the vector part is present, while the point is supplied in a different argument where needed.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"VectorBundleFibers refers to the whole set of fibers of a vector bundle. There is also another type, VectorSpaceAtPoint, that represents a specific fiber at a given point. This distinction is made to reduce the need to repeatedly construct objects of type VectorSpaceAtPoint in certain usage scenarios.","category":"page"},{"location":"manifolds/vector_bundle.html#FVector-1","page":"Vector bundle","title":"FVector","text":"","category":"section"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"For cases where confusion between different types of vectors is possible, the type FVector can be used to express which type of vector space the vector belongs to. It is used for example in musical isomorphisms (the flat! and sharp! functions) that are used to go from a tangent space to cotangent space and vice versa.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Modules = [Manifolds]\nPages = [\"VectorBundle.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/vector_bundle.html#Manifolds.FVector","page":"Vector bundle","title":"Manifolds.FVector","text":"FVector(type::VectorSpaceType, data)\n\nDecorator indicating that the vector data from a fiber of a vector bundle is of type type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundle","page":"Vector bundle","title":"Manifolds.VectorBundle","text":"VectorBundle(M::Manifold, type::VectorSpaceType)\n\nVector bundle on manifold M of type type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundleFibers","page":"Vector bundle","title":"Manifolds.VectorBundleFibers","text":"VectorBundleFibers(VS::VectorSpaceType, M::Manifold)\n\nType representing a family of vector spaces (fibers) of a vector bundle over M with vector spaces of type VS. In contrast with VectorBundle, operations on VectorBundleFibers expect point-like and vector-like parts to be passed separately instead of being bundled together. It can be thought of as a representation of vector spaces from a vector bundle but without storing the point at which a vector space is attached (which is specified separately in various functions).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceAtPoint","page":"Vector bundle","title":"Manifolds.VectorSpaceAtPoint","text":"VectorSpaceAtPoint(fiber::VectorBundleFibers, x)\n\nA vector space (fiber type fiber of a vector bundle) at point x from the manifold fiber.M.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceType","page":"Vector bundle","title":"Manifolds.VectorSpaceType","text":"VectorSpaceType\n\nAbstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.\n\nEvery vector space VS is supposed to provide:\n\na method of constructing vectors,\nbasic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),\nzero_vector!(VS, v, x) to construct zero vectors at point x,\nsimilar(v, T) for vector v,\ncopyto!(v, w) for vectors v and w,\neltype(v) for vector v,\nvector_space_dimension(::VectorBundleFibers{<:typeof(VS)}) where VS.\n\nOptionally:\n\ninner product via inner (used to provide Riemannian metric on vector bundles),\nflat! and sharp!,\nnorm (by default uses inner),\nproject_vector! (for embedded vector spaces),\nrepresentation_size (if support for ProductArray is desired),\nbroadcasting for basic operations.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.CotangentSpaceAtPoint-Tuple{Manifold,Any}","page":"Vector bundle","title":"Manifolds.CotangentSpaceAtPoint","text":"CotangentSpaceAtPoint(M::Manifold, x)\n\nReturn an object of type VectorSpaceAtPoint representing cotangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TangentSpaceAtPoint-Tuple{Manifold,Any}","page":"Vector bundle","title":"Manifolds.TangentSpaceAtPoint","text":"TangentSpaceAtPoint(M::Manifold, x)\n\nReturn an object of type VectorSpaceAtPoint representing tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.bundle_projection-Tuple{VectorBundle,Any}","page":"Vector bundle","title":"Manifolds.bundle_projection","text":"bundle_projection(B::VectorBundle, x::ProductRepr)\n\nProjection of point x from the bundle M to the base manifold. Returns the point on the base manifold B.M at which the vector part of x is attached.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.distance-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"Manifolds.distance","text":"distance(B::VectorBundleFibers, x, v, w)\n\nDistance between vectors v and w from the vector space at point x from the manifold M.M, that is the base manifold of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.flat!-Tuple{Manifold,FVector,Any,FVector}","page":"Vector bundle","title":"Manifolds.flat!","text":"flat!(M::Manifold, v::FVector, x, w::FVector)\n\nCompute the flat isomorphism (one of the musical isomorphisms) of vector w from the vector space of type M at point x from manifold M.M.\n\nThe function can be used for example to transform vectors from the tangent bundle to vectors from the cotangent bundle flat colon TM to T^*M\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.inner-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"Manifolds.inner","text":"inner(B::VectorBundleFibers, x, v, w)\n\nInner product of vectors v and w from the vector space of type B.VS at point x from manifold B.M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.sharp!-Tuple{Manifold,FVector,Any,FVector}","page":"Vector bundle","title":"Manifolds.sharp!","text":"sharp!(M::Manifold, v::FVector, x, w::FVector)\n\nCompute the sharp isomorphism (one of the musical isomorphisms) of vector w from the vector space of type M at point x from manifold M.M.\n\nThe function can be used for example to transform vectors from the cotangent bundle to vectors from the tangent bundle sharp colon T^*M to TM\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.vector_space_dimension-Tuple{VectorBundleFibers}","page":"Vector bundle","title":"Manifolds.vector_space_dimension","text":"vector_space_dimension(B::VectorBundleFibers)\n\nDimension of the vector space of type B.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.zero_vector!-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"Manifolds.zero_vector!","text":"zero_vector!(B::VectorBundleFibers, v, x)\n\nSave the zero vector from the vector space of type B.VS at point x from manifold B.M to v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.zero_vector-Tuple{VectorBundleFibers,Any}","page":"Vector bundle","title":"Manifolds.zero_vector","text":"zero_vector(B::VectorBundleFibers, x)\n\nCompute the zero vector from the vector space of type B.VS at point x from manifold B.M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TensorProductType","page":"Vector bundle","title":"Manifolds.TensorProductType","text":"TensorProductType(spaces::VectorSpaceType...)\n\nVector space type corresponding to the tensor product of given vector space types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.project_vector!-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"Manifolds.project_vector!","text":"project_vector!(B::VectorBundleFibers, v, x, w)\n\nProject vector w from the vector space of type B.VS at point x and save the result to v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.similar_result-Tuple{VectorBundleFibers,Any,Vararg{Any,N} where N}","page":"Vector bundle","title":"Manifolds.similar_result","text":"similar_result(B::VectorBundleFibers, f, x...)\n\nAllocates an array for the result of function f that is an element of the vector space of type B.VS on manifold B.M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.similar_result_type-Union{Tuple{N}, Tuple{VectorBundleFibers,Any,Tuple{Vararg{Any,N}}}} where N","page":"Vector bundle","title":"Manifolds.similar_result_type","text":"similar_result_type(B::VectorBundleFibers, f, args::NTuple{N,Any}) where N\n\nReturns type of element of the array that will represent the result of function f for representing an operation with result in the vector space VS for manifold M on given arguments (passed at a tuple).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/array.html#Array-manifold-1","page":"Array manifold","title":"Array manifold","text":"","category":"section"},{"location":"manifolds/array.html#","page":"Array manifold","title":"Array manifold","text":"Modules = [Manifolds]\nPages = [\"ArrayManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/array.html#Manifolds.ArrayManifold","page":"Array manifold","title":"Manifolds.ArrayManifold","text":"ArrayManifold{M <: Manifold} <: Manifold\n\nA manifold to encapsulate manifolds working on array representations of MPoints and TVectors in a transparent way, such that for these manifolds its not necessary to introduce explicit types for the points and tangent vectors, but they are encapusalted/stripped automatically when needed.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Metric-manifold-1","page":"Metric manifold","title":"Metric manifold","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds]\nPages = [\"Metric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/metric.html#Manifolds.HasMetric","page":"Metric manifold","title":"Manifolds.HasMetric","text":"HasMetric\n\nA Trait to mark a Manifold M as being shorthand for a MetricManifold{M,G} with metric G. This can be used to forward functions called on the MetricManifold to the already-imlemented functions for the Manifold.\n\nFor example,\n\n@traitfn function my_feature(M::MMT, k...) where {MT<:Manifold,\n                                                  GT<:Metric,\n                                                  MMT<:MetricManifold{MT,GT};\n                                                  HasMetric{MT,GT}}\n    return my_feature(M.manifold, k...)\nend\n\nforwards the function my_feature from M to the already-implemented my_feature on the base manifold M.manifold. A manifold with a default metric can then be written\n\nstruct MyManifold{T} <: Manifold end\nstruct MyMetric{S} <: Metric end\n@traitimpl HasMetric{MyManifold,MyMetric}\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.LorentzMetric","page":"Metric manifold","title":"Manifolds.LorentzMetric","text":"LorentzMetric <: Metric\n\nAbstract type for Lorentz metrics, which have a single time dimension. These metrics assume the spacelike convention with the time dimension being last, giving the signature (+++-).\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.Metric","page":"Metric manifold","title":"Manifolds.Metric","text":"Metric\n\nAbstract type for the pseudo-Riemannian metric tensor g, a family of smoothly varying inner products on the tangent space. See inner.\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.MetricManifold","page":"Metric manifold","title":"Manifolds.MetricManifold","text":"MetricManifold{M<:Manifold,G<:Metric} <: Manifold\n\nEquip a manifold with a metric. Such a manifold is generally called pseudo- or semi-Riemannian. Each MetricManifold must implement local_metric.\n\nConstructor\n\nMetricManifold(manifold, metric)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.RiemannianMetric","page":"Metric manifold","title":"Manifolds.RiemannianMetric","text":"RiemannianMetric <: Metric\n\nAbstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for v in T_x M, the inner product g(v v)  0 whenever v is not the zero vector.\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Base.exp","page":"Metric manifold","title":"Base.exp","text":"exp(M::MetricManifold, x, v, args...)\n\nIf the HasMetric trait is defined for M, compute the exponential map of the base manifold. Otherwise, numerically integrate the exponential map assuming the Levi-Civita connection. See solve_exp_ode\n\nCurrently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_first-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_first","text":"christoffel_symbols_first(M::MetricManifold, x)\n\nCompute the Christoffel symbols of the first kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)\n\nGamma_ijk = frac12 leftg_kji + g_ikj - g_ijkright\n\nwhere g_ijk=fracpartialpartial x^k g_ij is the coordinate derivative of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_second-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_second","text":"christoffel_symbols_second(M::MetricManifold, x)\n\nCompute the Christoffel symbols of the second kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)\n\nGamma^l_ij = g^kl Gamma_ijk\n\nwhere Gamma_ijk are the Christoffel symbols of the first kind, and g^kl is the inverse of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (lij).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.det_local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.det_local_metric","text":"det_local_metric(M::MetricManifold, x)\n\nDeterminant of local matrix representation of the metric tensor g\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.einstein_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.einstein_tensor","text":"einstein_tensor(M::MetricManifold, x)\n\nCompute the Einstein tensor of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.gaussian_curvature-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.gaussian_curvature","text":"gaussian_curvature(M::MetricManifold, x)\n\nCompute the Gaussian curvature of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.inverse_local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.inverse_local_metric","text":"inverse_local_metric(M::MetricManifold, x)\n\nLocal matrix representation of the inverse metric (cometric) tensor, usually written g^ij\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.local_metric","text":"local_metric(M::MetricManifold, x)\n\nLocal matrix representation at the point x of the metric tensor g on the manifold M, usually written g_ij. The matrix has the property that g(v w)=v^T g_ij w = g_ij v^i w^j, where the latter expression uses Einstein summation convention.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.log_local_metric_density-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.log_local_metric_density","text":"log_local_metric_density(M::MetricManifold, x)\n\nReturn the natural logarithm of the metric density rho of M at x, which is given by rho=log sqrtdet g_ij.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.metric-Tuple{MetricManifold}","page":"Metric manifold","title":"Manifolds.metric","text":"metric(M::MetricManifold)\n\nGet the metric g of the manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_curvature-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.ricci_curvature","text":"ricci_curvature(M::MetricManifold, x)\n\nCompute the Ricci scalar curvature of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.ricci_tensor","text":"ricci_tensor(M::MetricManifold, x)\n\nCompute the Ricci tensor, also known as the Ricci curvature tensor, of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.riemann_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.riemann_tensor","text":"riemann_tensor(M::MetricManifold, x)\n\nCompute the Riemann tensor R^l_ijk, also known as the Riemann curvature tensor, at the point x. The dimensions of the resulting multi-dimensional array are ordered (lijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric_jacobian-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.local_metric_jacobian","text":"local_metric_jacobian(M::MetricManifold, x)\n\nGet partial derivatives of the local metric of M at x with respect to the coordinates of x, fracpartialpartial x^k g_ij = g_ijk. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.solve_exp_ode-Tuple{MetricManifold,Any,Any,Any}","page":"Metric manifold","title":"Manifolds.solve_exp_ode","text":"solve_exp_ode(M::MetricManifold,\n              x,\n              v,\n              tspan;\n              solver=AutoVern9(Rodas5()),\n              kwargs...)\n\nApproximate the exponential map on the manifold over the provided timespan assuming the Levi-Civita connection by solving the ordinary differential equation\n\nfracd^2dt^2 x^k + Gamma^k_ij fracddt x_i fracddt x_j = 0\n\nwhere Gamma^k_ij are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed. The arguments tspan and solver follow the OrdinaryDiffEq conventions. kwargs... specify keyword arguments that will be passed to OrdinaryDiffEq.solve.\n\nCurrently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\n\n\n","category":"method"},{"location":"distributions.html#Distributions-1","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Following functions and types provide support for manifold-valued and tangent space-valued distributions.","category":"page"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Modules = [Manifolds]\nPages = [\"DistributionsBase.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"distributions.html#Manifolds.FVectorDistribution","page":"Distributions","title":"Manifolds.FVectorDistribution","text":"FVectorDistribution{TSpace<:VectorBundleFibers, T}\n\nAn abstract distribution for tangent vectors at point of type T from vector space of type TSpace.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.FVectorSupport","page":"Distributions","title":"Manifolds.FVectorSupport","text":"FVectorSupport(space::Manifold, VectorBundleFibers)\n\nValue support for tangent vector-valued distributions (values from tangent space at point x from given manifold).\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.FVectorvariate","page":"Distributions","title":"Manifolds.FVectorvariate","text":"FVectorvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a vector from a fiber of a vector bundle.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointDistribution","page":"Distributions","title":"Manifolds.MPointDistribution","text":"MPointDistribution{TM<:Manifold}\n\nAn abstract distribution for points on manifold of type TM.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointSupport","page":"Distributions","title":"Manifolds.MPointSupport","text":"MPointSupport(manifold::Manifold)\n\nValue support for manifold-valued distributions (values from given manifold M).\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointvariate","page":"Distributions","title":"Manifolds.MPointvariate","text":"MPointvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a point on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Distributions.support-Union{Tuple{T}, Tuple{T}} where T<:Manifolds.FVectorDistribution","page":"Distributions","title":"Distributions.support","text":"support(d::FVectorDistribution)\n\nGet the object of type FVectorSupport for the distribution d.\n\n\n\n\n\n","category":"method"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Manifolds.ProjectedPointDistribution\nManifolds.ProjectedFVectorDistribution","category":"page"},{"location":"distributions.html#Manifolds.ProjectedPointDistribution","page":"Distributions","title":"Manifolds.ProjectedPointDistribution","text":"ProjectedPointDistribution(m::Manifold, d, proj!, x)\n\nGenerates a random point in ambient space of m and projects it to m using function proj!. Generated arrays are of type TResult, which can be specified by providing the x argument.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.ProjectedFVectorDistribution","page":"Distributions","title":"Manifolds.ProjectedFVectorDistribution","text":"ProjectedFVectorDistribution(type::VectorBundleFibers, x, d, project_vector!)\n\nGenerates a random vector from ambient space of manifold type.manifold at point x and projects it to vector space of type type using function project_vector!. Generated arrays are of type TResult.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Public-Documentation-1","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public.html#","page":"Public","title":"Public","text":"Documentation for Manifolds.jl's public interface.","category":"page"},{"location":"lib/public.html#","page":"Public","title":"Public","text":"Manifolds.ShapeSpecification\nsubmanifold_component\nManifolds.ProductArray\nProductRepr\nManifolds.prod_point","category":"page"},{"location":"lib/public.html#Manifolds.ShapeSpecification","page":"Public","title":"Manifolds.ShapeSpecification","text":"ShapeSpecification(reshapers, manifolds::Manifold...)\n\nA structure for specifying array size and offset information for linear storage of points and tangent vectors on the product manifold of manifolds.\n\nThe first argument, reshapers, indicates how a view representing a point in the ProductArray will be reshaped. It can either be an object of type AbstractReshaper that will be applied to all views or a tuple of such objects that will be applied to subsequent manifolds.\n\nTwo main reshaping methods are provided by types StaticReshaper that is faster for manifolds represented by small arrays (up to about 100 elements) and ArrayReshaper that is faster for larger arrays.\n\nFor example, consider the shape specification for the product of a sphere and group of rotations:\n\njulia> M1 = Sphere(2)\nSphere{2}()\n\njulia> M2 = Manifolds.Rotations(2)\nManifolds.Rotations{2}()\n\njulia> reshaper = Manifolds.StaticReshaper()\nManifolds.StaticReshaper()\n\njulia> shape = Manifolds.ShapeSpecification(reshaper, M1, M2)\nManifolds.ShapeSpecification{(1:3, 4:7),Tuple{Tuple{3},Tuple{2,2}},\n  Tuple{Manifolds.StaticReshaper,Manifolds.StaticReshaper}}(\n  (Manifolds.StaticReshaper(), Manifolds.StaticReshaper()))\n\nTRanges contains ranges in the linear storage that correspond to a specific manifold. Sphere(2) needs three numbers and is first, so it is allocated the first three elements of the linear storage (1:3). Rotations(2) needs four numbers and is second, so the next four numbers are allocated to it (4:7). TSizes describe how the linear storage must be reshaped to correctly represent points. In this case, Sphere(2) expects a three-element vector, so the corresponding size is Tuple{3}. On the other hand, Rotations(2) expects two-by-two matrices, so its size specification is Tuple{2,2}.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.submanifold_component","page":"Public","title":"Manifolds.submanifold_component","text":"submanifold_component(x::ProductArray, i::Integer)\n\nProject the product array x to its ith component. A new array is returned.\n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#Manifolds.ProductArray","page":"Public","title":"Manifolds.ProductArray","text":"ProductArray(shape::ShapeSpecification, data)\n\nAn array-based representation for points and tangent vectors on the product manifold. data contains underlying representation of points arranged according to TRanges and TSizes from shape. Internal views for each specific sub-point are created and stored in parts.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.ProductRepr","page":"Public","title":"Manifolds.ProductRepr","text":"ProductRepr(parts)\n\nA more general but slower representation of points and tangent vectors on a product manifold.\n\nExample:\n\nA product point on a product manifold Sphere(2) × Euclidean(2) might be created as\n\nProductRepr([1.0, 0.0, 0.0], [2.0, 3.0])\n\nwhere [1.0, 0.0, 0.0] is the part corresponding to the sphere factor and [2.0, 3.0] is the part corresponding to the euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.prod_point","page":"Public","title":"Manifolds.prod_point","text":"prod_point(M::ShapeSpecification, pts...)\n\nConstruct a product point from product manifold M based on point pts represented by ProductArray.\n\nExample\n\nTo construct a point on the product manifold S^2 times mathbbR^2 from points on the sphere and in the euclidean space represented by, respectively, [1.0, 0.0, 0.0] and [-3.0, 2.0] you need to construct shape specification first. It describes how linear storage of ProductArray corresponds to array representations expected by Sphere(2) and Euclidean(2).\n\nM1 = Sphere(2)\nM2 = Euclidean(2)\nreshaper = Manifolds.StaticReshaper()\nMshape = Manifolds.ShapeSpecification(reshaper, M1, M2)\n\nNext, the desired point on the product manifold can be obtained by calling Manifolds.prod_point(Mshape, [1.0, 0.0, 0.0], [-3.0, 2.0]).\n\n\n\n","category":"function"},{"location":"lib/internals.html#Internal-Documentation-1","page":"Internals","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/internals.html#","page":"Internals","title":"Internals","text":"Documentation for Manifolds.jl's internal methods and types.","category":"page"},{"location":"lib/internals.html#","page":"Internals","title":"Internals","text":"Manifolds.SizedAbstractArray\nManifolds.ziptuples\nManifolds.size_to_tuple\nManifolds.select_from_tuple\nManifolds.find_pv","category":"page"},{"location":"lib/internals.html#Manifolds.SizedAbstractArray","page":"Internals","title":"Manifolds.SizedAbstractArray","text":"SizedAbstractArray{Tuple{dims...}}(array)\n\nWraps an Array with a static size, so to take advantage of the (faster) methods defined by the static array package. The size is checked once upon construction to determine if the number of elements (length) match, but the array may be reshaped. (Also, Size(dims...)(array) acheives the same thing)\n\n\n\n\n\n","category":"type"},{"location":"lib/internals.html#Manifolds.ziptuples","page":"Internals","title":"Manifolds.ziptuples","text":"ziptuples(a, b)\n\nZips tuples a and b in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\nziptuples(a, b, c)\n\nZips tuples a, b and c in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\nziptuples(a, b, c, d)\n\nZips tuples a, b, c and d in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\nziptuples(a, b, c, d, e)\n\nZips tuples a, b, c, d and e in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.size_to_tuple","page":"Internals","title":"Manifolds.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.select_from_tuple","page":"Internals","title":"Manifolds.select_from_tuple","text":"select_from_tuple(t::NTuple{N, Any}, positions::Val{P})\n\nSelects elements of tuple t at positions specified by the second argument. For example select_from_tuple((\"a\", \"b\", \"c\"), Val((3, 1, 1))) returns (\"c\", \"a\", \"a\").\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.find_pv","page":"Internals","title":"Manifolds.find_pv","text":"find_pv(x...)\n\nA = find_pv(x...) returns the first ProductArray among the arguments.\n\n\n\n\n\n","category":"function"}]
}
