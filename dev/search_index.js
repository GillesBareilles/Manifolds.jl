var documenterSearchIndex = {"docs":
[{"location":"lib/internals.html#Internal-Documentation-1","page":"Internals","title":"Internal Documentation","text":"","category":"section"},{"location":"lib/internals.html#","page":"Internals","title":"Internals","text":"Documentation for Manifolds.jl's internal methods and types.","category":"page"},{"location":"lib/internals.html#","page":"Internals","title":"Internals","text":"Manifolds.SizedAbstractArray\nManifolds.ziptuples\nManifolds.size_to_tuple\nManifolds.select_from_tuple\nManifolds.find_pv","category":"page"},{"location":"lib/internals.html#Manifolds.SizedAbstractArray","page":"Internals","title":"Manifolds.SizedAbstractArray","text":"SizedAbstractArray{Tuple{dims...}}(array)\n\nWraps an AbstractArray with a static size, so to take advantage of the (faster) methods defined by the static array package. The size is checked once upon construction to determine if the number of elements (length) match, but the array may be reshaped.\n\n\n\n\n\n","category":"type"},{"location":"lib/internals.html#Manifolds.ziptuples","page":"Internals","title":"Manifolds.ziptuples","text":"ziptuples(a, b)\n\nZips tuples a and b in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\nziptuples(a, b, c)\n\nZips tuples a, b and c in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\nziptuples(a, b, c, d)\n\nZips tuples a, b, c and d in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\nziptuples(a, b, c, d, e)\n\nZips tuples a, b, c, d and e in a fast, type-stable way. If they have different lengths, the result is trimmed to the length of the shorter tuple.\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.size_to_tuple","page":"Internals","title":"Manifolds.size_to_tuple","text":"size_to_tuple(::Type{S}) where S<:Tuple\n\nConverts a size given by Tuple{N, M, ...} into a tuple (N, M, ...).\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.select_from_tuple","page":"Internals","title":"Manifolds.select_from_tuple","text":"select_from_tuple(t::NTuple{N, Any}, positions::Val{P})\n\nSelects elements of tuple t at positions specified by the second argument. For example select_from_tuple((\"a\", \"b\", \"c\"), Val((3, 1, 1))) returns (\"c\", \"a\", \"a\").\n\n\n\n\n\n","category":"function"},{"location":"lib/internals.html#Manifolds.find_pv","page":"Internals","title":"Manifolds.find_pv","text":"find_pv(x...)\n\nA = find_pv(x...) returns the first ProductArray among the arguments.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/choleskyspace.html#Cholesky-Space-1","page":"Cholesky Space","title":"Cholesky Space","text":"","category":"section"},{"location":"manifolds/choleskyspace.html#","page":"Cholesky Space","title":"Cholesky Space","text":"The Cholesky Space is a Riemannian manifold on the lower triangular matrices.","category":"page"},{"location":"manifolds/choleskyspace.html#","page":"Cholesky Space","title":"Cholesky Space","text":"Modules = [Manifolds]\nPages = [\"CholeskySpace.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/choleskyspace.html#Manifolds.CholeskySpace","page":"Cholesky Space","title":"Manifolds.CholeskySpace","text":"CholeskySpace{N} <: Manifold\n\nthe manifold of lower triangular matrices with positive diagonal and a metric based on the cholesky decomposition. The formulae for this manifold are for example summarized in Table 1 of [Lin2019].\n\n[Lin2019]: Lin, Zenhua: \"Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition\", arXiv: 1908.09326.\n\n\n\n","category":"type"},{"location":"manifolds/choleskyspace.html#","page":"Cholesky Space","title":"Cholesky Space","text":"Modules = [Manifolds]\nPages = [\"CholeskySpace.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{CholeskySpace{N},Any,Any}} where N","page":"Cholesky Space","title":"ManifoldsBase.distance","text":"distance(M,x,y)\n\ncomputes the Riemannian distance on the CholeskySpace M between two matrices x, y that are lower triangular with positive diagonal. The formula reads\n\nd_mathcal M(xy) = sqrt\nsum_ij (x_ij-y_ij)^2 +\nsum_j=1^m (log x_jj - log y_jj)^2\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.exp!-Union{Tuple{N}, Tuple{CholeskySpace{N},Any,Any,Any}} where N","page":"Cholesky Space","title":"ManifoldsBase.exp!","text":"exp!(M,y,x,v)\n\ncompute the exponential map on the CholeskySpace M eminating from the lower triangular matrix with positive diagonal x towards the lower triangular matrix v and return the result in y. The formula reads\n\nexp_x v = lfloor x rfloor + lfloor v rfloor\n+operatornamediag(x)operatornamediag(x)expbigl( operatornamediag(v)operatornamediag(x)^-1bigr)\n\nwhere lfloor xrfloor denotes the strictly lower triangular matrix of x and operatornamediag(x) the diagonal matrix of x\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.inner-Union{Tuple{N}, Tuple{CholeskySpace{N},Any,Any,Any}} where N","page":"Cholesky Space","title":"ManifoldsBase.inner","text":"inner(M,x,v,w)\n\ncomputes the inner product on the CholeskySpace M at the lower triangular matric with positive diagonal x and the two tangent vectors v,w, i.e they are both lower triangular matrices with arbitrary diagonal. The formula reads\n\n    g_x(vw) = sum_ij v_ijw_ij + sum_j=1^m v_iiw_iix_ii^-2\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.log!-Union{Tuple{N}, Tuple{CholeskySpace{N},Any,Any,Any}} where N","page":"Cholesky Space","title":"ManifoldsBase.log!","text":"log!(M,v,x,y)\n\ncompute the exponential map on the CholeskySpace M eminating from the lower triangular matrix with positive diagonal x towards the lower triangular matrx v and return the result in y. The formula reads\n\nlog_x v = lfloor x rfloor - lfloor y rfloor\n+operatornamediag(x)logbigl(operatornamediag(y)operatornamediag(x)^-1bigr)\n\nwhere lfloor xrfloor denotes the strictly lower triangular matrix of x and operatornamediag(x) the diagonal matrix of x\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.vector_transport_to!-Union{Tuple{N}, Tuple{CholeskySpace{N},Any,Any,Any,Any,ParallelTransport}} where N","page":"Cholesky Space","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport!(M,vto,x,v,y)\n\nparallely transport the tangent vector v at x along the geodesic to y on respect to the CholeskySpace manifold M. The formula reads\n\n    mathcal P_xto y(v) = lfloor v rfloor  + operatornamediag(y)operatornamediag(x)^-1operatornamediag(v)\n\nwhere lfloorcdotrfloor denotes the strictly lower triangular matrix, and operatornamediag extracts the diagonal matrix.\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.zero_tangent_vector!-Union{Tuple{N}, Tuple{CholeskySpace{N},Any,Any}} where N","page":"Cholesky Space","title":"ManifoldsBase.zero_tangent_vector!","text":"zero_tangent_vector!(M,v,x)\n\nreturns the zero tangent vector on the CholeskySpace M at x in the variable v.\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{CholeskySpace{N},Any,Any}} where N","page":"Cholesky Space","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M,x,v; kwargs... )\n\nchecks whether v is a tangent vector to x on the CholeskySpace M, i.e. atfer check_manifold_point(M,x), v has to be of same dimension as x and a symmetric matrix. The tolerance for the tests can be set using the kwargs....\n\n\n\n\n\n","category":"method"},{"location":"manifolds/choleskyspace.html#Literature-1","page":"Cholesky Space","title":"Literature","text":"","category":"section"},{"location":"manifolds/metric.html#Metric-manifold-1","page":"Metric manifold","title":"Metric manifold","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"A Riemannian manifold always consists of a topological manifold together with a smoothly varying metric g.","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"However, often there is an implicitly assumed (default) metric, like the usual inner product on Euclidean space. This decorator takes this into account. It is not necessary to use this decorator if you implement just one (or the first) metric. If you later introduce a second, the old (first) metric can be used with the (non MetricManifold) Manifold, i.e. without an explicitly stated metric. The decorator acts transparent in that sense; see is_decorator_manifold for details.","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"This manifold decorator serves two purposes: to implement different metrics (e.g. in closed form) for one Manifold and to provide a way to compute geodesics on manifolds, where this Metric does not yield closed formula. ","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"Let's first look at the provided types.","category":"page"},{"location":"manifolds/metric.html#Types-1","page":"Metric manifold","title":"Types","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"Metric.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/metric.html#Manifolds.LorentzMetric","page":"Metric manifold","title":"Manifolds.LorentzMetric","text":"LorentzMetric <: Metric\n\nAbstract type for Lorentz metrics, which have a single time dimension. These metrics assume the spacelike convention with the time dimension being last, giving the signature (+++-).\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.Metric","page":"Metric manifold","title":"Manifolds.Metric","text":"Metric\n\nAbstract type for the pseudo-Riemannian metric tensor g, a family of smoothly varying inner products on the tangent space. See inner.\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.MetricManifold","page":"Metric manifold","title":"Manifolds.MetricManifold","text":"MetricManifold{M<:Manifold,G<:Metric} <: Manifold\n\nEquip a Manifold explicitly with a Metric G.\n\nFor a Metric Manifold, by default, assumes, that you implement the linear form from local_metric in order to evaluate the exponential map.\n\nIf the corresponding Metric G yields closed form formulae for e.g. the exponential map and this is implemented directly (without solving the ode), you can of course still implement that directly.\n\nConstructor\n\nMetricManifold(manifold, metric)\n\n\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Manifolds.RiemannianMetric","page":"Metric manifold","title":"Manifolds.RiemannianMetric","text":"RiemannianMetric <: Metric\n\nAbstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for v in T_x M, the inner product g(v v)  0 whenever v is not the zero vector.\n\n\n\n","category":"type"},{"location":"manifolds/metric.html#Implement-Different-Metrics-on-the-same-Manifold-1","page":"Metric manifold","title":"Implement Different Metrics on the same Manifold","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"In order to distinguish different metrics on one manifold, one can introduce two Metrics and use this type to dispatch on the metric, see  SymmetricPositiveDefinite. To avoid overhead, one Metric can then be marked as being the default, i.e. the one that is used, when no MetricManifold decorator is present. This avoids reimplementation of the first existing metric, access to the metric-dependent functions that were implemented using the undecorated manifold, as well as the transparent fallback of the corresponding MetricManifold with default metric to the undecorated implementations. This does not cause any runtime overhead. Introducing a default Metric serves a better readability of the code when working with different metrics.","category":"page"},{"location":"manifolds/metric.html#Implementation-of-Metrics-1","page":"Metric manifold","title":"Implementation of Metrics","text":"","category":"section"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"For the case that a local_metric is implemented as a bilinear form that is positive definite, the following further functions are provided, unless the corresponding Metric is marked as default – then the fallbacks mentioned in the last section are used for e.g. the exp!onential map.","category":"page"},{"location":"manifolds/metric.html#","page":"Metric manifold","title":"Metric manifold","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"Metric.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_first-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_first","text":"christoffel_symbols_first(M::MetricManifold, x; backend=:default)\n\nCompute the Christoffel symbols of the first kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)\n\nGamma_ijk = frac12 leftg_kji + g_ikj - g_ijkright\n\nwhere g_ijk=fracpartialpartial x^k g_ij is the coordinate derivative of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_second-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_second","text":"christoffel_symbols_second(M::MetricManifold, x; backend=:default)\n\nCompute the Christoffel symbols of the second kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)\n\nGamma^l_ij = g^kl Gamma_ijk\n\nwhere Gamma_ijk are the Christoffel symbols of the first kind, and g^kl is the inverse of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered (lij).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.christoffel_symbols_second_jacobian-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.christoffel_symbols_second_jacobian","text":"christoffel_symbols_second_jacobian(M::MetricManifold, x; backend = :default)\n\nGet partial derivatives of the Christoffel symbols of the second kind for manifold M at x with respect to the coordinates of x, fracpartialpartial x^l Gamma^k_ij = Gamma^k_ijl The dimensions of the resulting multi-dimensional array are ordered (ijkl).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.det_local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.det_local_metric","text":"det_local_metric(M::MetricManifold, x)\n\nDeterminant of local matrix representation of the metric tensor g\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.einstein_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.einstein_tensor","text":"einstein_tensor(M::MetricManifold, x; backend = :default)\n\nCompute the Einstein tensor of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.gaussian_curvature-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.gaussian_curvature","text":"gaussian_curvature(M::MetricManifold, x; backend = :default)\n\nCompute the Gaussian curvature of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.inverse_local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.inverse_local_metric","text":"inverse_local_metric(M::MetricManifold, x)\n\nLocal matrix representation of the inverse metric (cometric) tensor, usually written g^ij\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.is_default_metric-Tuple{Manifold,Metric}","page":"Metric manifold","title":"Manifolds.is_default_metric","text":"is_default_metric(M,G)\n\nindicate, whether the Metric G is the default metric for the Manifold M. This means that any occurence of MetricManifold(M,G) where typeof(is_default_metric(M,G)) = Val{true} falls back to just be called with M such that the Manifold M implicitly has this metric, for example if this was the first one implemented or is the one most commonly assumed to be used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.is_default_metric-Union{Tuple{MMT}, Tuple{MMT}} where MMT<:MetricManifold","page":"Metric manifold","title":"Manifolds.is_default_metric","text":"is_default_metric(MM)\n\nindicate, whether the Metric MM.G is the default metric for the Manifold MM.M within the MetricManifold MM. This means that any occurence of MetricManifold(MM.M,MM.G) where typeof(is_default_metric(MM.M,MM.G)) = Val{true} falls back to just be called with MM.MM such that the Manifold MM.M implicitly has the metric MM.G, for example if this was the first one implemented or is the one most commonly assumed to be used.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.local_metric","text":"local_metric(M::MetricManifold, x)\n\nLocal matrix representation at the point x of the metric tensor g on the manifold M, usually written g_ij. The matrix has the property that g(v w)=v^T g_ij w = g_ij v^i w^j, where the latter expression uses Einstein summation convention.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.local_metric_jacobian-Tuple{Any,Any}","page":"Metric manifold","title":"Manifolds.local_metric_jacobian","text":"local_metric_jacobian(M::MetricManifold, x; backend=:default)\n\nGet partial derivatives of the local metric of M at x with respect to the coordinates of x, fracpartialpartial x^k g_ij = g_ijk. The dimensions of the resulting multi-dimensional array are ordered (ijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.log_local_metric_density-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.log_local_metric_density","text":"log_local_metric_density(M::MetricManifold, x)\n\nReturn the natural logarithm of the metric density rho of M at x, which is given by rho=log sqrtdet g_ij.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.metric-Tuple{MetricManifold}","page":"Metric manifold","title":"Manifolds.metric","text":"metric(M::MetricManifold)\n\nGet the metric g of the manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_curvature-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.ricci_curvature","text":"ricci_curvature(M::MetricManifold, x; backend = :default)\n\nCompute the Ricci scalar curvature of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.ricci_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.ricci_tensor","text":"ricci_tensor(M::MetricManifold, x; backend = :default)\n\nCompute the Ricci tensor, also known as the Ricci curvature tensor, of the manifold M at the point x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.riemann_tensor-Tuple{MetricManifold,Any}","page":"Metric manifold","title":"Manifolds.riemann_tensor","text":"riemann_tensor(M::MetricManifold, x)\n\nCompute the Riemann tensor R^l_ijk, also known as the Riemann curvature tensor, at the point x. The dimensions of the resulting multi-dimensional array are ordered (lijk).\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#ManifoldsBase.exp!-Union{Tuple{MMT}, Tuple{MMT,Val{false},Any,Any,Any}} where MMT<:MetricManifold","page":"Metric manifold","title":"ManifoldsBase.exp!","text":"exp(MM::MetricManifold, x, v, args...)\n\nNumerically integrate the exponential map assuming the Levi-Civita connection. See solve_exp_ode if the Metric G of the MetricManifold{M,G}` is not marked as the default one.\n\nCurrently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/metric.html#Manifolds.solve_exp_ode-NTuple{4,Any}","page":"Metric manifold","title":"Manifolds.solve_exp_ode","text":"solve_exp_ode(M::MetricManifold, x, v, tspan; backend=:default, solver=AutoVern9(Rodas5()), kwargs...)\n\nApproximate the exponential map on the manifold over the provided timespan assuming the Levi-Civita connection by solving the ordinary differential equation\n\nfracd^2dt^2 x^k + Gamma^k_ij fracddt x_i fracddt x_j = 0\n\nwhere Gamma^k_ij are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed. The arguments tspan and solver follow the OrdinaryDiffEq conventions. kwargs... specify keyword arguments that will be passed to OrdinaryDiffEq.solve.\n\nCurrently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.\n\n\n\n","category":"method"},{"location":"manifolds/array.html#Array-manifold-1","page":"Array manifold","title":"Array manifold","text":"","category":"section"},{"location":"manifolds/array.html#","page":"Array manifold","title":"Array manifold","text":"Modules = [ManifoldsBase]\nPages = [\"ArrayManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/array.html#ManifoldsBase.ArrayCoTVector","page":"Array manifold","title":"ManifoldsBase.ArrayCoTVector","text":"ArrayCoTVector <: CoTVector\n\nrepresent a cotangent vector an ArrayManfold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically this distinguished the value from ArrayMPoints and ArrayTVectors\n\n\n\n\n\n","category":"type"},{"location":"manifolds/array.html#ManifoldsBase.ArrayMPoint","page":"Array manifold","title":"ManifoldsBase.ArrayMPoint","text":"ArrayMPoint <: MPoint\n\nrepresent a point on an ArrayManifold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically this distinguished the value from ArrayTVectors and ArrayCoTVectors\n\n\n\n\n\n","category":"type"},{"location":"manifolds/array.html#ManifoldsBase.ArrayManifold","page":"Array manifold","title":"ManifoldsBase.ArrayManifold","text":"ArrayManifold{M <: Manifold} <: Manifold\n\nA manifold to encapsulate manifolds working on array representations of MPoints and TVectors in a transparent way, such that for these manifolds its not necessary to introduce explicit types for the points and tangent vectors, but they are encapsulated/stripped automatically when needed.\n\nThis manifold is a decorator for a manifold, i.e. it decorates a manifold M with types points, vectors, and covectors.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/array.html#ManifoldsBase.ArrayTVector","page":"Array manifold","title":"ManifoldsBase.ArrayTVector","text":"ArrayTVector <: TVector\n\nrepresent a tangent vector an ArrayManfold, i.e. on a manifold where data can be represented by arrays. The array is stored internally and semantically this distinguished the value from ArrayMPoints and ArrayCoTVectors\n\n\n\n\n\n","category":"type"},{"location":"manifolds/array.html#ManifoldsBase.array_value-Tuple{AbstractArray}","page":"Array manifold","title":"ManifoldsBase.array_value","text":"array_value(x)\n\nreturns the internal array value of a ArrayMPoint, ArrayTVector or ArrayCoTVector if the value x is encapsulated as such, otherwise if x is already an array, it just returns x\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#Symmetric-matrices-1","page":"Symmetric Matrices","title":"Symmetric matrices","text":"","category":"section"},{"location":"manifolds/symmetric.html#","page":"Symmetric Matrices","title":"Symmetric Matrices","text":"Modules = [Manifolds]\nPages = [\"Symmetric.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/symmetric.html#Manifolds.SymmetricMatrices","page":"Symmetric Matrices","title":"Manifolds.SymmetricMatrices","text":"SymmetricMatrices{n,T} <: Manifold\n\nThe Manifold $ \\operatorname{Sym} (n)$ consisting of the T-valued, symmetric matrices of size $ n\\times n$, i.e. the set \n\noperatornameSym(n) = biglA in mathbb F^ntimes n big A^mathrmT = A bigr\n\nwhere mathbb F in  mathbb R mathbb C. For T, there is a distinction between \n\nT = Real: real-valued matrix entries\nT = Complex: complex-valued matrix entries\n\nBeing slightly inefficient, the matrices are safed as ntimes n arrays despite the redundance of the lower triangle.\n\nConstructor\n\nSymmetricMatrices(n::Int,T::Type = Real)\n\n\n\n","category":"type"},{"location":"manifolds/symmetric.html#Manifolds.flat!-Tuple{SymmetricMatrices,FVector{Manifolds.CotangentSpaceType,TData} where TData,Any,FVector{Manifolds.TangentSpaceType,TData} where TData}","page":"Symmetric Matrices","title":"Manifolds.flat!","text":"flat!(M::SymmetricMatrices, v::FVector{CotangentSpaceType}, x, w::FVector{TangentSpaceType})\n\nComputes the flat! isomorphism of the SymmetricMatrices manifold M  on the manifold point x and tangent vector w.  The result is stored in v. \n\nAs M is already a vector space over mathbb R, this returns just the vector w.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#Manifolds.sharp!-Tuple{SymmetricMatrices,FVector{Manifolds.TangentSpaceType,TData} where TData,Any,FVector{Manifolds.CotangentSpaceType,TData} where TData}","page":"Symmetric Matrices","title":"Manifolds.sharp!","text":"sharp!(M::SymmetricMatrices, v::FVector{TangentSpaceType}, x, w::FVector{CotangentSpaceType})\n\nComputes the sharp! isomorphism of the SymmetricMatrices manifold M  on the manifold point x and cotangent vector w.  The result is stored in v. \n\nAs M is already a vector space over mathbb R, this returns just the vector w.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.exp!-Tuple{SymmetricMatrices,Any,Any,Any}","page":"Symmetric Matrices","title":"ManifoldsBase.exp!","text":"exp!(M::SymmetricMatrices, y, x, v)\n\nComputes the exponential map exp! of the tangent vector v at manifold point x lying on the SymmetricMatrices manifold M.  The result is saved in y.  For the SymmetricMatrices, the exponential map is simply the sum, i.e. \n\n    y = x + v\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.inner-Tuple{SymmetricMatrices,Any,Any,Any}","page":"Symmetric Matrices","title":"ManifoldsBase.inner","text":"inner(M::SymmetricMatrices, x, w, v)\n\ncompute the inner product of the two tangent vectors w,v from the tangent plane at x on the SymmetricMatrices M using the restriction of the metric from the embedding, i.e. \n\n(vw)_x = operatornametr(v^mathrmTw)\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.log!-Tuple{SymmetricMatrices,Any,Any,Any}","page":"Symmetric Matrices","title":"ManifoldsBase.log!","text":"log!(M::SymmetricMatrices, v, x, y)\n\nComputes the logarithmic map from the manifold point x to the manifold point y, both lying on the SymmetricMatrices manifold M.  The result is saved in v.  For the SymmetricMatrices, the logarithmic map is simply the difference, i.e. \n\n    v = y-x\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricMatrices{N,Complex}}, Tuple{N}} where N","page":"Symmetric Matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricMatrices{n,Complex})\n\nReturn the dimension of the SymmetricMatrices matrix M with complex-valued entries, i.e. \n\n    n(n+1)\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricMatrices{N,Real}}, Tuple{N}} where N","page":"Symmetric Matrices","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::SymmetricMatrices{n,Real})\n\nReturn the dimension of the SymmetricMatrices matrix M with real-valued entries, i.e. \n\n    fracn(n+1)2\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.project_point!-Tuple{SymmetricMatrices,Any}","page":"Symmetric Matrices","title":"ManifoldsBase.project_point!","text":"project_point!(M::SymmetricMatrices,x)\n\nImplements the project_point of an arbitrary matrix x onto the manifold of SymmetricMatrices, i.e. \n\nx_new = frac12 left( x_old + x_old^mathrmT right)\n\nThe value of the variable x is overwritten.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.project_tangent!-Tuple{SymmetricMatrices,Any,Any,Any}","page":"Symmetric Matrices","title":"ManifoldsBase.project_tangent!","text":"project_tangent!(M::SymmetricMatrices, w, x, v)\n\nImplements the project_tangent! of the matrix v onto the tangent space of the manifold of SymmetricMatrices, i.e. the SymmetricMatrices itself. The result is stored in w:\n\nw = frac12 left( v + v^mathrmT right)\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.vector_transport_to!-Tuple{SymmetricMatrices,Any,Any,Any,Any,ParallelTransport}","page":"Symmetric Matrices","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::SymmetricMatrices, vto, x, v, y)\n\nComputes the vector_transport_to!  of the tangent vector v from the manifold point x on the SymmetricMatrices M to the manifold point yin M. The result is stored in vto. Since the metric is inherited from the embedding space, this is just the identity.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.check_manifold_point-Union{Tuple{T}, Tuple{N}, Tuple{SymmetricMatrices{N,T},Any}} where T where N","page":"Symmetric Matrices","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::SymmetricMatrices,x; kwargs...)\n\nChecks whether x is a valid manifold point on the SymmetricMatrices M, i.e. is a symmetric matrix of size (N,N) with values of type T.\n\nThe tolerance for the symmetry of x can be set using kwargs.\n\n\n\n","category":"method"},{"location":"manifolds/symmetric.html#ManifoldsBase.check_tangent_vector-Union{Tuple{T}, Tuple{N}, Tuple{SymmetricMatrices{N,T},Any,Any}} where T where N","page":"Symmetric Matrices","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::SymmetricMatrices,x,v; kwargs... )\n\nChecks whether v is a valid tangent vector to manifold point x on the SymmetricMatrices matrices M, i.e. after is_manifold_point(M,x), v has to be a symmetric matrix of dimension (N,N).\n\nThe tolerance for the symmetry of x can be set using kwargs.\n\n\n\n\n\n","category":"method"},{"location":"distributions.html#Distributions-1","page":"Distributions","title":"Distributions","text":"","category":"section"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Following functions and types provide support for manifold-valued and tangent space-valued distributions.","category":"page"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Modules = [Manifolds]\nPages = [\"DistributionsBase.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"distributions.html#Manifolds.FVectorDistribution","page":"Distributions","title":"Manifolds.FVectorDistribution","text":"FVectorDistribution{TSpace<:VectorBundleFibers, T}\n\nAn abstract distribution for tangent vectors at point of type T from vector space of type TSpace.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.FVectorSupport","page":"Distributions","title":"Manifolds.FVectorSupport","text":"FVectorSupport(space::Manifold, VectorBundleFibers)\n\nValue support for tangent vector-valued distributions (values from tangent space at point x from given manifold).\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.FVectorvariate","page":"Distributions","title":"Manifolds.FVectorvariate","text":"FVectorvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a vector from a fiber of a vector bundle.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointDistribution","page":"Distributions","title":"Manifolds.MPointDistribution","text":"MPointDistribution{TM<:Manifold}\n\nAn abstract distribution for points on manifold of type TM.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointSupport","page":"Distributions","title":"Manifolds.MPointSupport","text":"MPointSupport(manifold::Manifold)\n\nValue support for manifold-valued distributions (values from given manifold M).\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.MPointvariate","page":"Distributions","title":"Manifolds.MPointvariate","text":"MPointvariate\n\nStructure that subtypes VariateForm, indicating that a single sample is a point on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Distributions.support-Union{Tuple{T}, Tuple{T}} where T<:Manifolds.FVectorDistribution","page":"Distributions","title":"Distributions.support","text":"support(d::FVectorDistribution)\n\nGet the object of type FVectorSupport for the distribution d.\n\n\n\n\n\n","category":"method"},{"location":"distributions.html#","page":"Distributions","title":"Distributions","text":"Manifolds.ProjectedPointDistribution\nManifolds.ProjectedFVectorDistribution","category":"page"},{"location":"distributions.html#Manifolds.ProjectedPointDistribution","page":"Distributions","title":"Manifolds.ProjectedPointDistribution","text":"ProjectedPointDistribution(m::Manifold, d, proj!, x)\n\nGenerates a random point in ambient space of m and projects it to m using function proj!. Generated arrays are of type TResult, which can be specified by providing the x argument.\n\n\n\n\n\n","category":"type"},{"location":"distributions.html#Manifolds.ProjectedFVectorDistribution","page":"Distributions","title":"Manifolds.ProjectedFVectorDistribution","text":"ProjectedFVectorDistribution(type::VectorBundleFibers, x, d, project_vector!)\n\nGenerates a random vector from ambient space of manifold type.manifold at point x and projects it to vector space of type type using function project_vector!. Generated arrays are of type TResult.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/grassmann.html#Grassmann-Manifold-1","page":"Grassmannian","title":"Grassmann Manifold","text":"","category":"section"},{"location":"manifolds/grassmann.html#","page":"Grassmannian","title":"Grassmannian","text":"Modules = [Manifolds]\nPages = [\"Grassmann.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/grassmann.html#Manifolds.Grassmann","page":"Grassmannian","title":"Manifolds.Grassmann","text":"Grassmann{n,k,T} <: Manifold\n\nThe Grassmann manifold operatornameGr(nk) consists of all subspaces spanned by k linear independent vectors mathbb F^n, where mathbb F in mathbb R mathbb C is either the real- (or complex-) valued vectors. This yields all k-dimensional subspaces of mathbb R^n for the real-valued case and all 2k-dimensional subspaces of mathbb C^n for the second.\n\nThe manifold can be represented as\n\noperatornameGr(nk) coloneqq bigl operatornamespan(x)\n x in mathbb F^ntimes k barx^mathrmTx = I_k\n\nwhere barcdot^mathrmT denotes the complex conjugate transpose and I_k is the ktimes k identity matrix. This means, that the columns of x form an orthonormal basis of the subspace, that is a point on operatornameGr(nk), and hence the subspace can actually be represented by a whole equivalence class of representers. Another interpretation is, that\n\noperatornameGr(nk) = operatornameSt(nk)  operatornameO(k)\n\ni.e the Grassmann manifold is the quotient of the Stiefel manifold and the orthogonal group operatornameO(k) of orthogonal ktimes k matrices.\n\nThe tangent space at a point (subspace) x is given by\n\nT_xmathrmGr(nk) = bigl\nv in mathbbF^ntimes k \nbar v^mathrmTx + bar x^mathrmTv = 0_k bigr\n\nwhere 0_k denotes the ktimes k zero matrix.\n\nNote that a point xin operatornameGr(nk) might be represented by different matrices (i.e. matrices with orthonormal column vectors that span the same subspace). Different representations of x also lead to different representation matrices for the tangent space T_xmathrmGr(nk)\n\nThe manifold is named after Hermann G. Graßmann (1809-1877).\n\nConstructor\n\nGrassmann(n,k,T=Real)\n\ngenerate the Grassmann manifold operatornameGr(nk), where the real-valued case mathbb F = mathbb R is the default.\n\n\n\n","category":"type"},{"location":"manifolds/grassmann.html#","page":"Grassmannian","title":"Grassmannian","text":"Modules = [Manifolds]\nPages = [\"Grassmann.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/grassmann.html#ManifoldsBase.distance-Union{Tuple{T}, Tuple{K}, Tuple{N}, Tuple{Grassmann{N,K,T},Any,Any}} where T where K where N","page":"Grassmannian","title":"ManifoldsBase.distance","text":"distance(M,x,y)\n\ncomputes the Riemannian distance on Grassmann manifold M= mathrmGr(nk).\n\nLet USV = bar x^mathrmTy denote the SVD decomposition of bar x^mathrmTy, where barcdot^mathrmT denotes the complex conjugate transposed. Then the distance is given by\n\nd_mathrmGR(nk)(xy) = operatornamenorm(operatornameRe(b))\n\nwhere\n\nb_i=begincases 0  textif  S_i geq 1 operatornameacos(S_i)   textif  S_i1 endcases\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.exp!-Union{Tuple{T}, Tuple{K}, Tuple{N}, Tuple{Grassmann{N,K,T},Any,Any,Any}} where T where K where N","page":"Grassmannian","title":"ManifoldsBase.exp!","text":"exp!(M, y, x, v)\n\ncompute the exponential map on the Grassmann manifold M= mathrmGr(nk) starting in x with tangent vector (direction) v and store the result in y. Let v = USV denote the SVD decomposition of v. Then the exponential map is written using\n\nz = x Vcos(S)bar V^mathrmT + Usin(S)bar V^mathrmT\n\nwhere barcdot^mathrmT denotes the complex conjugate transposed. The cosine and sine are applied element wise to the diagonal entries of S. A final QR decomposition z=QR is performed for numerical stability reasons, yielding the result as\n\ny = Q\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inner-Union{Tuple{T}, Tuple{K}, Tuple{N}, Tuple{Grassmann{N,K,T},Any,Any,Any}} where T where K where N","page":"Grassmannian","title":"ManifoldsBase.inner","text":"inner(M,x,v,w)\n\ncompute the inner product for two tangent vectors v, w from the tangent space of x on the Grassmann manifold M. The formula reads\n\n(vw)_x = operatornametrace(bar v^mathrmTw)\n\nwhere barcdot^mathrmT denotes the complex conjugate transposed.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inverse_retract!-Union{Tuple{T}, Tuple{K}, Tuple{N}, Tuple{Grassmann{N,K,T},Any,Any,Any,PolarInverseRetraction}} where T where K where N","page":"Grassmannian","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M, v, x, y, ::PolarInverseRetraction)\n\ncompute the inverse retraction for the PolarRetraction\n\noperatornameretr_x^-1y = y*(barx^mathrmTy)^-1 - x\n\nwhere barcdot^mathrmT denotes the complex conjugate transposed.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.inverse_retract!-Union{Tuple{T}, Tuple{K}, Tuple{N}, Tuple{Grassmann{N,K,T},Any,Any,Any,QRInverseRetraction}} where T where K where N","page":"Grassmannian","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M, v, x, y, ::QRInverseRetraction)\n\ncompute the inverse retraction valid of the QRRetraction\n\noperatornameretr_x^-1y = y*(barx^mathrmTy)^-1 - x\n\nwhere barcdot^mathrmT denotes the complex conjugate transposed.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.log!-Union{Tuple{T}, Tuple{K}, Tuple{N}, Tuple{Grassmann{N,K,T},Any,Any,Any}} where T where K where N","page":"Grassmannian","title":"ManifoldsBase.log!","text":"log!(M, v, x, y)\n\ncompute the logarithmic map on the Grassmann manifold mathcal M=mathrmGr(nk), i.e. the tangent vector v whose corresponding geodesic starting from x reaches y after time 1 on M. The formula reads\n\nv = Vcdot operatornameatan(S) cdot bar U^mathrmT\n\nwhere barcdot^mathrmT denotes the complex conjugate transposed, U and V are the unitary matrices, and S is a diagonal matrix containing the singular values of the SVD-decomposition of\n\nUSV = (bar y^mathrmTx)^-1 ( bar y^mathrmT - bar y^mathrmTxbar x^mathrmT )\n\nIn this formula the operatornameatan is meant elementwise.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.manifold_dimension-Union{Tuple{Grassmann{N,K,Complex}}, Tuple{K}, Tuple{N}} where K where N","page":"Grassmannian","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M)\n\nreturn the dimension of the complex-valued Grassmann(n,k) manifold M, i.e.\n\n2k(n-k)\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.manifold_dimension-Union{Tuple{Grassmann{N,K,Real}}, Tuple{K}, Tuple{N}} where K where N","page":"Grassmannian","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M)\n\nreturn the dimension of the real-valued Grassmann(n,k) manifold M, i.e.\n\nk(n-k)\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.retract!-Union{Tuple{T}, Tuple{K}, Tuple{N}, Tuple{Grassmann{N,K,T},Any,Any,Any,PolarRetraction}} where T where K where N","page":"Grassmannian","title":"ManifoldsBase.retract!","text":"retract!(M, y, x, v, ::PolarRetraction)\n\ncompute the SVD-based retraction PolarRetraction on the Grassmann manifold M. With USV = x + v the retraction reads\n\ny = operatornameretr_x v = UbarV^mathrmT\n\nwhere barcdot^mathrmT denotes the complex conjugate transposed.\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#ManifoldsBase.retract!-Union{Tuple{T}, Tuple{K}, Tuple{N}, Tuple{Grassmann{N,K,T},Any,Any,Any,QRRetraction}} where T where K where N","page":"Grassmannian","title":"ManifoldsBase.retract!","text":"retract!(M, y, x, v, ::QRRetraction )\n\ncompute the QR-based retraction QRRetraction on the Grassmann manifold M. With QR = x + v the retraction reads\n\ny = operatornameretr_xv = QD\n\nwhere D is a mtimes n matrix with\n\nD = operatornamediag( operatornamesgn(R_ii+05)_i=1^n )\n\n\n\n","category":"method"},{"location":"manifolds/grassmann.html#Statistics.mean-Tuple{Grassmann{N,K,Real} where K where N,Vararg{Any,N} where N}","page":"Grassmannian","title":"Statistics.mean","text":"mean(\n    M::Grassmann{N,K,Real},\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/4);\n    kwargs...,\n) where {N,K}\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"lib/autodiff.html#Automatic-Differentiation-1","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"","category":"section"},{"location":"lib/autodiff.html#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Documentation for Manifolds.jl's methods and types for automatic differentiation.","category":"page"},{"location":"lib/autodiff.html#","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Manifolds.adbackend\nManifolds.adbackend!\nManifolds.adbackends","category":"page"},{"location":"lib/autodiff.html#Manifolds.adbackend","page":"Automatic Differentiation","title":"Manifolds.adbackend","text":"adbackend(backend::Symbol = :default) -> Symbol\n\nCheck if autodiff backend is valid (see adbackends) and return formatted. Note that backend=:default returns the current backend.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#Manifolds.adbackend!","page":"Automatic Differentiation","title":"Manifolds.adbackend!","text":"adbackend!(backend::Symbol)\n\nSet current backend for autodiff to backend.\n\n\n\n\n\n","category":"function"},{"location":"lib/autodiff.html#Manifolds.adbackends","page":"Automatic Differentiation","title":"Manifolds.adbackends","text":"adbackends() -> Vector{Symbol}\n\nGet vector of currently valid AD backends.\n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#Public-Documentation-1","page":"Public","title":"Public Documentation","text":"","category":"section"},{"location":"lib/public.html#","page":"Public","title":"Public","text":"Documentation for Manifolds.jl's public interface.","category":"page"},{"location":"lib/public.html#","page":"Public","title":"Public","text":"Manifolds.ShapeSpecification\nsubmanifold_component\nManifolds.ProductArray\nProductRepr\nManifolds.prod_point\nManifolds.StaticReshaper\nManifolds.ArrayReshaper\nManifolds.make_reshape","category":"page"},{"location":"lib/public.html#Manifolds.ShapeSpecification","page":"Public","title":"Manifolds.ShapeSpecification","text":"ShapeSpecification(reshapers, manifolds::Manifold...)\n\nA structure for specifying array size and offset information for linear storage of points and tangent vectors on the product manifold of manifolds.\n\nThe first argument, reshapers, indicates how a view representing a point in the ProductArray will be reshaped. It can either be an object of type AbstractReshaper that will be applied to all views or a tuple of such objects that will be applied to subsequent manifolds.\n\nTwo main reshaping methods are provided by types StaticReshaper that is faster for manifolds represented by small arrays (up to about 100 elements) and ArrayReshaper that is faster for larger arrays.\n\nFor example, consider the shape specification for the product of a sphere and group of rotations:\n\njulia> M1 = Sphere(2)\nSphere{2}()\n\njulia> M2 = Manifolds.Rotations(2)\nManifolds.Rotations{2}()\n\njulia> reshaper = Manifolds.StaticReshaper()\nManifolds.StaticReshaper()\n\njulia> shape = Manifolds.ShapeSpecification(reshaper, M1, M2)\nManifolds.ShapeSpecification{(1:3, 4:7),Tuple{Tuple{3},Tuple{2,2}},\n  Tuple{Manifolds.StaticReshaper,Manifolds.StaticReshaper}}(\n  (Manifolds.StaticReshaper(), Manifolds.StaticReshaper()))\n\nTRanges contains ranges in the linear storage that correspond to a specific manifold. Sphere(2) needs three numbers and is first, so it is allocated the first three elements of the linear storage (1:3). Rotations(2) needs four numbers and is second, so the next four numbers are allocated to it (4:7). TSizes describe how the linear storage must be reshaped to correctly represent points. In this case, Sphere(2) expects a three-element vector, so the corresponding size is Tuple{3}. On the other hand, Rotations(2) expects two-by-two matrices, so its size specification is Tuple{2,2}.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.submanifold_component","page":"Public","title":"Manifolds.submanifold_component","text":"submanifold_component(x::ProductArray, i::Integer)\n\nProject the product array x to its ith component. A new array is returned.\n\n\n\n\n\n","category":"function"},{"location":"lib/public.html#Manifolds.ProductArray","page":"Public","title":"Manifolds.ProductArray","text":"ProductArray(shape::ShapeSpecification, data)\n\nAn array-based representation for points and tangent vectors on the product manifold. data contains underlying representation of points arranged according to TRanges and TSizes from shape. Internal views for each specific sub-point are created and stored in parts.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.ProductRepr","page":"Public","title":"Manifolds.ProductRepr","text":"ProductRepr(parts)\n\nA more general but slower representation of points and tangent vectors on a product manifold.\n\nExample:\n\nA product point on a product manifold Sphere(2) × Euclidean(2) might be created as\n\nProductRepr([1.0, 0.0, 0.0], [2.0, 3.0])\n\nwhere [1.0, 0.0, 0.0] is the part corresponding to the sphere factor and [2.0, 3.0] is the part corresponding to the euclidean manifold.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.prod_point","page":"Public","title":"Manifolds.prod_point","text":"prod_point(M::ShapeSpecification, pts...)\n\nConstruct a product point from product manifold M based on point pts represented by ProductArray.\n\nExample\n\nTo construct a point on the product manifold S^2 times mathbbR^2 from points on the sphere and in the euclidean space represented by, respectively, [1.0, 0.0, 0.0] and [-3.0, 2.0] you need to construct shape specification first. It describes how linear storage of ProductArray corresponds to array representations expected by Sphere(2) and Euclidean(2).\n\nM1 = Sphere(2)\nM2 = Euclidean(2)\nreshaper = Manifolds.StaticReshaper()\nMshape = Manifolds.ShapeSpecification(reshaper, M1, M2)\n\nNext, the desired point on the product manifold can be obtained by calling Manifolds.prod_point(Mshape, [1.0, 0.0, 0.0], [-3.0, 2.0]).\n\n\n\n","category":"function"},{"location":"lib/public.html#Manifolds.StaticReshaper","page":"Public","title":"Manifolds.StaticReshaper","text":"StaticReshaper()\n\nReshaper that constructs SizedAbstractArray.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.ArrayReshaper","page":"Public","title":"Manifolds.ArrayReshaper","text":"ArrayReshaper()\n\nReshaper that constructs Base.ReshapedArray.\n\n\n\n\n\n","category":"type"},{"location":"lib/public.html#Manifolds.make_reshape","page":"Public","title":"Manifolds.make_reshape","text":"make_reshape(reshaper::AbstractReshaper, ::Type{Size}, data) where Size\n\nReshape array data to size Size using method provided by reshaper.\n\n\n\n\n\n","category":"function"},{"location":"manifolds/sphere.html#Sphere-1","page":"Sphere","title":"Sphere","text":"","category":"section"},{"location":"manifolds/sphere.html#","page":"Sphere","title":"Sphere","text":"Modules = [Manifolds]\nPages = [\"Sphere.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/sphere.html#Manifolds.Sphere","page":"Sphere","title":"Manifolds.Sphere","text":"Sphere{N} <: Manifold\n\nThe unit sphere manifold mathbb S^n represented by n+1-Tuples, i.e. in by vectors in mathbb R^n+1 of unit length\n\nConstructor\n\nSphere(n)\n\ngenerates the mathbb S^nsubset mathbb R^n+1\n\n\n\n","category":"type"},{"location":"manifolds/sphere.html#Manifolds.normal_tvector_distribution-Tuple{Sphere,Any,Any}","page":"Sphere","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(S::Sphere, x, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.inner-Tuple{Sphere,Any,Any,Any}","page":"Sphere","title":"ManifoldsBase.inner","text":"inner(S::Sphere, x, w, v)\n\ncompute the inner product of the two tangent vectors w,v from the tangent plane at x on the sphere S=mathbb S^n using the restriction of the metric from the embedding, i.e. $ (v,w)_x = v^\\mathrm{T}w $.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.manifold_dimension-Union{Tuple{Sphere{N}}, Tuple{N}} where N","page":"Sphere","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(S::Sphere)\n\nReturn the dimension of the manifold mathbb S^n, i.e. n.\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Statistics.mean-Tuple{Sphere,Vararg{Any,N} where N}","page":"Sphere","title":"Statistics.mean","text":"mean(\n    S::Sphere,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#Manifolds.uniform_distribution-Tuple{Sphere,Any}","page":"Sphere","title":"Manifolds.uniform_distribution","text":"uniform_distribution(S::Sphere, x)\n\nUniform distribution on given sphere. Generated points will be of similar type to x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{Sphere{N},Any}} where N","page":"Sphere","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(S,x; kwargs...)\n\nchecks, whether x is a valid point on the Sphere S, i.e. is a vector of length manifold_dimension(S)+1 (approximately) of unit length. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/sphere.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{Sphere{N},Any,Any}} where N","page":"Sphere","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(S,x,v; kwargs... )\n\nchecks whether v is a tangent vector to x on the Sphere S, i.e. after check_manifold_point(S,x), v has to be of same dimension as x and orthogonal to x. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#Product-Manifold-1","page":"Power manifold","title":"Product Manifold","text":"","category":"section"},{"location":"manifolds/power.html#","page":"Power manifold","title":"Power manifold","text":"Power manifold P = M^N_1 times N_2 times dots times N_n of manifold N with shape N_1 times N_2 times dots times N_n. Canonical projections may depend on multiple indices i_1 i_2 dots i_n. For example, manifold-valued time series require a single index (n=1) and manifold-valued images require two indices (n=2).","category":"page"},{"location":"manifolds/power.html#","page":"Power manifold","title":"Power manifold","text":"Modules = [Manifolds]\nPages = [\"PowerManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/power.html#Manifolds.PowerManifold","page":"Power manifold","title":"Manifolds.PowerManifold","text":"PowerManifold{TM<:Manifold, TSize<:Tuple} <: Manifold\n\nPower manifold M^N_1 times N_2 times dots times N_n with power geometry. It is represented by an array-like structure with n dimensions and sizes N_1 N_2 dots N_n, along each dimension. TSize statically defines the number of elements along each axis. For example, a manifold-valued time series would be represented by a power manifold with n equal to 1 and N_1 equal to the number of samples. A manifold-valued image (for example in diffusion tensor imaging) would be represented by a two-axis power manifold (n=2) with N_1 and N_2 equal to width and height of the image.\n\nWhile the size of the manifold is static, points on the power manifold would not be represented by statically-sized arrays. Operations on small power manifolds might be faster if they are represented as ProductManifold.\n\nConstructor\n\nPowerManifold(M, N_1, N_2, ..., N_n)\n\ngenerates the power manifold M^N_1 times N_2 times dots times N_n.\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.InversePowerRetraction","page":"Power manifold","title":"Manifolds.InversePowerRetraction","text":"InversePowerRetraction(inverse_retractions::AbstractInverseRetractionMethod...)\n\nPower inverse retraction of inverse_retractions. Works on PowerManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerFVectorDistribution","page":"Power manifold","title":"Manifolds.PowerFVectorDistribution","text":"PowerFVectorDistribution([type::VectorBundleFibers], [x], distr)\n\nGenerates a random vector at point x from vector space (a fiber of a tangent bundle) of type type using the power distribution of distr.\n\nVector space type and x can be automatically inferred from distribution distr.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerPointDistribution","page":"Power manifold","title":"Manifolds.PowerPointDistribution","text":"PowerPointDistribution(M::PowerManifold, distribution)\n\nPower distribution on manifold M, based on distribution.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#Manifolds.PowerRetraction","page":"Power manifold","title":"Manifolds.PowerRetraction","text":"PowerRetraction(retraction::AbstractRetractionMethod)\n\nPower retraction based on retraction. Works on PowerManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/power.html#ManifoldsBase.check_manifold_point-Tuple{PowerManifold,Any}","page":"Power manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::ProductManifold, x; kwargs...)\n\nCheck whether x is a valid point on the ProductManifold M.\n\nThe tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/power.html#ManifoldsBase.check_tangent_vector-Tuple{PowerManifold,Any,Any}","page":"Power manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::ProductManifold, x, v; kwargs... )\n\nCheck whether v is a tangent vector to x on the ProductManifold M, i.e. atfer check_manifold_point(M, x), and all projections to base manifolds must be respective tangent vectors.\n\nThe tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Rotations-1","page":"Rotations","title":"Rotations","text":"","category":"section"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"The manifold mathrmSO(n) of orthogonal matrices with determinant +1 in mathbb R^ntimes n, i.e.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"mathrmSO(n) = biglR in mathbbR^ntimes n big RR^mathrmT =\nR^mathrmTR = mathrmI_n det(R) = 1 bigr","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"mathrmSO(n) is a subgroup of the orthogonal group mathrmO(n) and also known as the special orthogonal group or the set of rotations group.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Tangent vectors are represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Let L_Rcolon mathrmSO(n) to mathrmSO(n) where R in mathrmSO(n) be the left-multiplication by R, that is L_R(S) = RS. The tangent space at rotation R, T_R mathrmSO(n), is related to the tangent space at the identity rotation mathrmI_n by the differential of L_R at identity, (mathrmdL_R)_mathrmI_n colon T_mathrmI_n mathrmSO(n) to T_R mathrmSO(n). For a tangent vector at the identity rotation v in T_mathrmI_n mathrmSO(n) the matrix representation of the corresponding tangent vector w at a rotation R can be obtained by matrix multiplication: w=Rv in T_R mathrmSO(n). You can compare the functions log!(::Manifolds.Rotations, v, x, y) and exp!(::Manifolds.Rotations, y, x, v) to see how it works in practice.","category":"page"},{"location":"manifolds/rotations.html#","page":"Rotations","title":"Rotations","text":"Modules = [Manifolds]\nPages = [\"Rotations.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/rotations.html#Manifolds.Rotations","page":"Rotations","title":"Manifolds.Rotations","text":"Rotations{N} <: Manifold\n\nSpecial orthogonal manifold mathrmSO(n) represented by ntimes n real-valued orthogonal matrices with determinant +1.\n\nConstructor\n\nRotations(n)\n\ngenerates the mathrmSO(n) subset mathbb R^ntimes n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.hat!-Union{Tuple{N}, Tuple{Rotations{N},Any,Any,Any}} where N","page":"Rotations","title":"Manifolds.hat!","text":"hat!(M::Rotations, Ω, x, ω)\n\nConvert the unique tangent vector components omega at point x on rotations group mathrmSO(n) to the matrix representation Omega of the tangent vector. See vee! for the conventions used.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_tvector_distribution-Tuple{Rotations,Any,Any}","page":"Rotations","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(M::Rotations, x, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.vee!-Union{Tuple{N}, Tuple{Rotations{N},Any,Any,Any}} where N","page":"Rotations","title":"Manifolds.vee!","text":"vee!(M::Rotations, ω, x, Ω)\n\nExtract the unique tangent vector components omega at point x on rotations group mathrmSO(n) from the matrix representation Omega of the tangent vector.\n\nThe basis on the Lie algebra mathfrakso(n) is chosen such that for mathrmSO(2), omega=theta=Omega_21 is the angle of rotation, and for mathrmSO(3), omega = (Omega_32 Omega_13 Omega_21) = theta u is the angular velocity and axis-angle representation, where u is the unit vector along the axis of rotation.\n\nFor mathrmSO(n) where n ge 4, the additional elements of omega are omega_i (i - 3)2 + j + 1 = Omega_ij, for i in 4 n j in 1i).\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.exp!-Tuple{Rotations{4},Any,Any,Any}","page":"Rotations","title":"ManifoldsBase.exp!","text":"exp!(M::Rotations{4}, y, x, v)\n\nExponential map of tangent vector v at point x from mathrmSO(4) manifold M. Result is saved to y.\n\nThe algorithm used is a more numerically stable form of those proposed in [Gallier2002] and [Andrica2013].\n\n[Gallier2002]: Gallier J.; Xu D.; Computing exponentials of skew-symmetric matrices and logarithms of orthogonal matrices. International Journal of Robotics and Automation (2002), 17(4), pp. 1-11. pdf.\n\n[Andrica2013]: Andrica D.; Rohan R.-A.; Computing the Rodrigues coefficients of the exponential map of the Lie groups of matrices. Balkan Journal of Geometry and Its Applications (2013), 18(2), pp. 1-2. pdf.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inner-Tuple{Rotations,Any,Any,Any}","page":"Rotations","title":"ManifoldsBase.inner","text":"inner(M, x, w, v)\n\ncompute the inner product of the two tangent vectors w, v from the tangent plane at x on the special orthogonal space M=mathrmSO(n) using the restriction of the metric from the embedding, i.e.\n\n(v w)_x = operatornametr(v^T w)\n\n.\n\nTangent vectors are represented by matrices.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inverse_retract!-Tuple{Rotations,Any,Any,Any,PolarInverseRetraction}","page":"Rotations","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M, v, x, y, ::PolarInverseRetraction)\n\nCompute a vector from the tagent space T_xmathrmSO(n) of the point x on the Rotations manifold M with which the point y can be reached by the PolarRetraction from the point x after time 1.\n\nThe formula reads v = -frac12(x^mathrmTys - (x^mathrmTys)^mathrmT)\n\nwhere s is the solution to the Sylvester equation\n\nx^mathrmTys + s(x^mathrmTy)^mathrmT + 2mathrmI_n = 0\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.inverse_retract!-Union{Tuple{N}, Tuple{Rotations{N},Any,Any,Any,QRInverseRetraction}} where N","page":"Rotations","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M::Rotations, x, y, ::QRInverseRetraction)\n\nCompute a vector from the tagent space T_xmathrmSO(n) of the point x on the Rotations manifold M with which the point y can be reached by the QRRetraction from the point x after time 1.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.log!-Tuple{Rotations,Any,Any,Any}","page":"Rotations","title":"ManifoldsBase.log!","text":"log!(M::Rotations, v, x, y)\n\ncompute the logarithmic map on the Rotations manifold M=mathrmSO(n), which is given by\n\nlog_x y =\n  frac12 bigl(operatornameLog(x^mathrmTy)\n  - (operatornameLog x^mathrmTy)^mathrmT)\n\nwhere operatornameLog denotes the matrix logarithm, and save the result to v.\n\nFor antipodal rotations the function returns one of the tangent vectors that point at y.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.manifold_dimension-Union{Tuple{Rotations{N}}, Tuple{N}} where N","page":"Rotations","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Rotations)\n\nreturns the dimension of the manifold mathrmSO(n), i.e. fracn(n-1)2.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.project_point!-Union{Tuple{N}, Tuple{Rotations{N},Any,Any}} where N","page":"Rotations","title":"ManifoldsBase.project_point!","text":"project_point!(M::Rotations, y, x; check_det = true)\n\nProject x to the nearest point on manifold M and store in y.\n\nGiven the singular value decomposition x = U Sigma V^mathrmT, with the singular values sorted in descending order, the projection is\n\ny = U operatornamediagleft11dotsdet(U V^mathrmT)right V^mathrmT\n\nThe diagonal matrix ensures that the det(y) = +1. If x is expected to be almost special orthogonal, then you may avoid this check with check_det = false.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.retract!-Tuple{Rotations,Any,Any,Any,PolarRetraction}","page":"Rotations","title":"ManifoldsBase.retract!","text":"retract_polar!(M::Rotations, y, x, v, method::PolarRetraction)\n\nCompute the SVD-based retraction PolarRetraction, a second-order approximation of the exponential map.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.retract!-Union{Tuple{T}, Tuple{Rotations,AbstractArray{T,N} where N,Any,Any,QRRetraction}} where T","page":"Rotations","title":"ManifoldsBase.retract!","text":"retract!(M, y, x, v, method::QRRetraction)\n\nThis QR-based retraction is a first-order approximation of the exponential map.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Statistics.mean-Tuple{Rotations,Vararg{Any,N} where N}","page":"Rotations","title":"Statistics.mean","text":"mean(\n    M::Rotations,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolationWithinRadius(π/2/√2);\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolationWithinRadius.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.NormalRotationDistribution","page":"Rotations","title":"Manifolds.NormalRotationDistribution","text":"NormalRotationDistribution(M::Rotations, d::Distribution, x::TResult)\n\nDistribution that returns a random point on the manifold Rotations M. Random point is generated using base distribution d and the type of the result is adjusted to TResult.\n\nSee normal_rotation_distribution for details.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/rotations.html#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.angles_4d_skew_sym_matrix","text":"angles_4d_skew_sym_matrix(A)\n\nThe Lie algebra of mathrmSO(4) consists of 4x4 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than eigvals.\n\nBy convention, the returned values are sorted in decreasing order (corresponding to the same ordering of angles as cos_angles_4d_rotation_matrix).\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}","page":"Rotations","title":"Manifolds.cos_angles_4d_rotation_matrix","text":"cos_angles_4d_rotation_matrix(R)\n\n4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system\n\nbeginaligned\ncosalpha + cosbeta = frac12 operatornametr(R)\ncosalpha + cosbeta = frac18 operatornametr(R)^2\n                           - frac116 operatornametr((R - R^T)^2) - 1\nendaligned\n\nBy convention, the returned values are sorted in increasing order. See angles_4d_skew_sym_matrix. For derivation of the above, see [Gallier, 2013].\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Rotations{N},Any,Real}} where N","page":"Rotations","title":"Manifolds.normal_rotation_distribution","text":"normal_rotation_distribution(M::Rotations, x, σ::Real)\n\nreturn a random point on the manifold Rotations M by generating a (Gaussian) random orthogonal matrix with determinant +1. Let\n\nQR = A\n\nbe the QR decomposition of a random matrix A, then the formula reads\n\nx = QD\n\nwhere D is a diagonal matrix with the signs of the diagonal entries of R, i.e.\n\nD_ij=begincases operatornamesgn(R_ij)  textif  i=j  0   textotherwise endcases\n\nIt can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.\n\nThe argument x is used to determine the type of returned points.\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{Rotations{N},Any}} where N","page":"Rotations","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M,x; kwargs...)\n\nchecks, whether x is a valid point on the Rotations M, i.e. is an array of size manifold_dimension(M) and represents a valid rotation. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{Rotations{N},Any,Any}} where N","page":"Rotations","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M,x,v; kwargs... )\n\nchecks whether v is a tangent vector to x on the Rotations space M, i.e. after check_manifold_point(M,x), v has to be of same dimension as x and orthogonal to x. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/rotations.html#Literature-1","page":"Rotations","title":"Literature","text":"","category":"section"},{"location":"interface.html#ManifoldsBase.jl-–-An-Interface-for-Manifolds-1","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl – An Interface for Manifolds","text":"","category":"section"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The interface for a manifold is provided in the lightweight package `ManifoldsBase.jl separate from the collection of manifolds in here. You can easily implement your algorithms and even first own manifolds just using the interface.","category":"page"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"The following functions are currently available from the interface. If a manifold that you implement for your own package fits this interface, we happily look forward to a Pull Request to add it here.","category":"page"},{"location":"interface.html#","page":"ManifoldsBase.jl","title":"ManifoldsBase.jl","text":"Modules = [ManifoldsBase]\nPages = [\"ManifoldsBase.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"interface.html#ManifoldsBase.CoTVector","page":"ManifoldsBase.jl","title":"ManifoldsBase.CoTVector","text":"CoTVector\n\nType for a cotangent vector of a manifold. While a Manifold not necessarily requires this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of cotangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.MPoint","page":"ManifoldsBase.jl","title":"ManifoldsBase.MPoint","text":"MPoint\n\nType for a point on a manifold. While a Manifold not necessarily requires this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of points on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.Manifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.Manifold","text":"Manifold\n\nA manifold type. The Manifold is used to dispatch to different exponential and logarithmic maps as well as other function on manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ParallelTransport","page":"ManifoldsBase.jl","title":"ManifoldsBase.ParallelTransport","text":"ParallelTransport <: AbstractVectorTransportMethod\n\nSpecify to use parallel transport as vector transport method within vector_transport_to, vector_transport_direction or vector_transport_along.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.ProjectionTransport","page":"ManifoldsBase.jl","title":"ManifoldsBase.ProjectionTransport","text":"ProjectionTransport <: AbstractVectorTransportMethod\n\nSpecify to use projection onto tangent space as vector transport method within vector_transport_to, vector_transport_direction or vector_transport_along. See project_tangent for details.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.TVector","page":"ManifoldsBase.jl","title":"ManifoldsBase.TVector","text":"TVector\n\nType for a tangent vector of a manifold. While a Manifold not necessarily requires this type, for example when it is implemented for Vectors or Matrix type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of tangent vectors and their types on a manifold.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#Base.exp-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}","page":"ManifoldsBase.jl","title":"Base.exp","text":"exp(M::Manifold, x, v, T::AbstractVector)\n\nExponential map of tangent vector t*v at point x from manifold M for each t in T.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.exp-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"Base.exp","text":"exp(M::Manifold, x, v, t=1)\n\nExponential map of tangent vector t*v at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.isapprox-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"Base.isapprox","text":"isapprox(M::Manifold, x, v, w; kwargs...)\n\nCheck if vectors v and w tangent at x from manifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#Base.isapprox-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"Base.isapprox","text":"isapprox(M::Manifold, x, y; kwargs...)\n\nCheck if points x and y from manifold M are approximately equal.\n\nKeyword arguments can be used to specify tolerances.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#LinearAlgebra.norm-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"LinearAlgebra.norm","text":"norm(M::Manifold, x, v)\n\nNorm of tangent vector v at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.base_manifold-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.base_manifold","text":"base_manifold(M::Manifold)\n\nreturns the internally stored manifold for decorated manifolds and the base manifold for vector bundles or power manifolds. For decorator manifolds it returns the dimension of the internally stored manifold.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::Manifold, x; kwargs...)\n\nReturn nothing when x is a point on manifold M. Otherwise, return a string with description why the point does not belong to manifold M.\n\nBy default, check_manifold_point returns nothing, i.e. if no checks are implmented, the assumption is to be optimistic for point not deriving from the MPoint type.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::Manifold, x, v; kwargs...)\n\ncheck, whether v is a valid tangent vector in the tangent plane of x on the Manifold M. An implementation should first check manifold_point_error(M, x; kwargs...) and then validate v. If it is not a tangent vector error string should be returned.\n\nBy default, check_tangent_vector returns nothing, i.e. if no checks are implmented, the assumption is to be optimistic for tangent vectors not deriving from the TVector type.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.distance","text":"distance(M::Manifold, x, y)\n\nShortest distance between the points x and y on manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any,Real}","page":"ManifoldsBase.jl","title":"ManifoldsBase.exp!","text":"exp!(M::Manifold, y, x, v, t=1)\n\nExponential map of tangent vector t*v at point x from manifold M. Result is saved to y.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}","page":"ManifoldsBase.jl","title":"ManifoldsBase.geodesic","text":"geodesic(M::Manifold, x, v, T::AbstractVector)\n\nGet the points for each t in T traveling from x along the geodesic with initial point x and velocity v.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any,Real}","page":"ManifoldsBase.jl","title":"ManifoldsBase.geodesic","text":"geodesic(M::Manifold, x, v, t)\n\nGet the point at time t traveling from x along the geodesic with initial point x and velocity v.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.geodesic","text":"geodesic(M::Manifold, x, v)\n\nGet the geodesic with initial point x and velocity v. The geodesic is the curve of constant velocity that is locally distance-minimizing. This function returns a function of time, which may be a Real or an AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.injectivity_radius-Tuple{Manifold,Any,AbstractRetractionMethod}","page":"ManifoldsBase.jl","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Manifold, x, R::AbstractRetractionMethod)\n\nDistance d such that retract(M, x, v, R) is injective for all tangent vectors shorter than d (has a left inverse).\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.injectivity_radius-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Manifold, x)\n\nDistance d such that exp(M, x, v) is injective for all tangent vectors shorter than d (has a left inverse).\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.injectivity_radius-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M::Manifold)\n\nInfimum of the injectivity radii of all manifold points.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inner","text":"inner(M::Manifold, x, v, w)\n\nInner product of tangent vectors v and w at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any,ManifoldsBase.LogarithmicInverseRetraction}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inverse_retract!","text":"inverse_retract!(M::Manifold, v, x, y, [method::AbstractInverseRetractionMethod=LogarithmicInverseRetraction()])\n\nInverse retraction (cheaper, approximate version of logarithmic map) of points x and y. Result is saved to y.\n\nInverse retraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any,AbstractInverseRetractionMethod}","page":"ManifoldsBase.jl","title":"ManifoldsBase.inverse_retract","text":"inverse_retract(M::Manifold, x, y, [method::AbstractInverseRetractionMethod])\n\nInverse retraction (cheaper, approximate version of logarithmic map) of points x and y from manifold M.\n\nInverse retraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.is_decorator_manifold-Union{Tuple{T}, Tuple{T}} where T<:Manifold","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_decorator_manifold","text":"is_decorator_manifold(M)\n\nindicate whether a manifold is a decorator manifold, i.e. whether it encapsulates a Manifold with additional features, and stores internally the original manifold instance. An example is the ArrayManifold.\n\nUsing Tim Holys Traits Trick (THTT), certain functions are just calling themselves on the internal manifold, and hence have not to be implemented for decorators again, for example manifold_dimension and especially base_manifold. This also assumes, that the undecoratord (base) manifold is stored in M.manifold.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.is_manifold_point","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_manifold_point","text":"is_manifold_point(M, x, throw_error = false; kwargs...)\n\ncheck, whether x is a valid point on the Manifold M.\n\nIf throw_error is false, the function returns either true or false. If throw_error if true, the function either returns true or throws an error. By default the function calls check_manifold_point(M, x; kwargs...) and checks whether the returned value is nothing or an error.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.is_tangent_vector","page":"ManifoldsBase.jl","title":"ManifoldsBase.is_tangent_vector","text":"is_tangent_vector(M, x, v, throw_error = false; kwargs...)\n\ncheck, whether v is a valid tangent vector at point x on the Manifold M.\n\nIf throw_error is false, the function returns either true or false. If throw_error if true, the function either returns true or throws an error. By default the function calls check_tangent_vector(M, x, v; kwargs...) and checks whether the returned value is nothing or an error.\n\n\n\n\n\n","category":"function"},{"location":"interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Manifold)\n\nThe dimension n of real space mathbb R^n to which the neighborhood of each point of the manifold is homeomorphic. For decorator manifolds it returns the dimension of the internally stored manifold.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project_point!-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project_point!","text":"project_point!(M::Manifold, y, x)\n\nProject point x from the ambient space onto the manifold M. The point y is overwritten by the projection. The function works only for selected embedded manifolds and is not required to return the closest point.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project_point-Tuple{Manifold,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project_point","text":"project_point(M::Manifold, x)\n\nProject point from the ambient space onto the manifold M. The point x is not modified. The function works only for selected embedded manifolds and is not required to return the closest point.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project_tangent!-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project_tangent!","text":"project_tangent!(M::Manifold, w, x, v)\n\nProject ambient space representation of a vector v to a tangent vector at point x from the manifold M. The result is saved in vector w.\n\nThe function works only for selected embedded manifolds and is not required to return the closest vector.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.project_tangent","text":"project_tangent(M::Manifold, x, v)\n\nProject ambient space representation of a vector v to a tangent vector at point x from the manifold M.\n\nThe function works only for selected embedded manifolds and is not required to return the closest vector.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.representation_size-Tuple{Manifold}","page":"ManifoldsBase.jl","title":"ManifoldsBase.representation_size","text":"representation_size(M::Manifold)\n\nThe size of array representing a point on manifold M. For decorator manifolds it returns the dimension of the internally stored manifold.\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any,ManifoldsBase.ExponentialRetraction}","page":"ManifoldsBase.jl","title":"ManifoldsBase.retract!","text":"retract!(M::Manifold, y, x, v, [t=1], [method::AbstractRetractionMethod=ExponentialRetraction()])\n\nRetraction (cheaper, approximate version of exponential map) of tangent vector t*v at point x from manifold M. Result is saved to y.\n\nRetraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any,AbstractRetractionMethod}","page":"ManifoldsBase.jl","title":"ManifoldsBase.retract","text":"retract(M::Manifold, x, v, [t=1], [method::AbstractRetractionMethod])\n\nRetraction (cheaper, approximate version of exponential map) of tangent vector t*v at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}","page":"ManifoldsBase.jl","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::Manifold, x, y, T::AbstractVector)\n\nGet the points for each t in T traveling from x along a shortest geodesic connecting x and y, where y is reached at t=1.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any,Real}","page":"ManifoldsBase.jl","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::Manifold, x, y, t)\n\nGet the point at time t traveling from x along a shortest geodesic connecting x and y, where y is reached at t=1.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.shortest_geodesic","text":"shortest_geodesic(M::Manifold, x, y)\n\nGet a geodesic with initial point x and point y at t=1 whose length is the shortest path between the two points. When there are multiple shortest geodesics, there is no guarantee which will be returned. This function returns a function of time, which may be a Real or an AbstractVector.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along!","text":"vector_transport_along!(M::Manifold, vto, x, v, c[,m=::ParallelTransport])\n\nVector transport of vector v at point x along the curve c such that c(0) is equal to x to point c(1) using the method m, which defaults to ParallelTransport. The result is saved to vto.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_along","text":"vector_transport_along(M::Manifold, x, v, c[,m])\n\nVector transport of vector v at point x along the curve c such that c(0) is equal to x to point c(1). The default method m used is ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_direction!","text":"vector_transport_direction!(M::Manifold, vto, x, v, vdir, m=::ParallelTransport])\n\nVector transport of vector v at point x in the direction indicated by the tangent vector vdir at point x. The result is saved to vto. By default, exp and vector_transport_to! are used with the method m which defaults to ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_direction","text":"vector_transport_direction(M::Manifold, x, v, vdir[, m=::ParallelTransport])\n\nVector transport of vector v at point x in the direction indicated by the tangent vector vdir at point x using the method m, which defaults to ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Manifold, vto, x, v, y, ProjectionTransport())\n\nImplements a default projection based vector transport, that projects a tangent vector v at x on a Manifold M onto the tangent space at y by interperting v as an element of the embedding and projecting back.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Manifold, vto, x, v, y, m::AbstractVectorTransportMethod=ParallelTransport())\n\nVector transport of vector v at point x to point y. The result is saved to vto. By default, the method m is ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"ManifoldsBase.vector_transport_to","text":"vector_transport_to(M::Manifold, x, v, y, m::AbstractVectorTransportMethod=ParallelTransport())\n\nVector transport of vector v at point x to point y using the method m, which defaults to ParallelTransport.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.ExponentialRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.ExponentialRetraction","text":"ExponentialRetraction\n\nRetraction using the exponential map.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.LogarithmicInverseRetraction","page":"ManifoldsBase.jl","title":"ManifoldsBase.LogarithmicInverseRetraction","text":"LogarithmicInverseRetraction\n\nInverse retraction using the logarithmic map.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#ManifoldsBase.OutOfInjectivityRadiusError","page":"ManifoldsBase.jl","title":"ManifoldsBase.OutOfInjectivityRadiusError","text":"OutOfInjectivityRadiusError\n\nAn error thrown when a function (for example logarithmic map or inverse retraction) is given arguments outside of its injectivity radius.\n\n\n\n\n\n","category":"type"},{"location":"interface.html#Base.angle-Tuple{Manifold,Any,Any,Any}","page":"ManifoldsBase.jl","title":"Base.angle","text":"angle(M::Manifold, x, v, w)\n\nAngle between tangent vectors v and w at point x from manifold M.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.similar_result-Tuple{Manifold,Any,Vararg{Any,N} where N}","page":"ManifoldsBase.jl","title":"ManifoldsBase.similar_result","text":"similar_result(M::Manifold, f, x...)\n\nAllocates an array for the result of function f on manifold M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\nUsefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.\n\n\n\n\n\n","category":"method"},{"location":"interface.html#ManifoldsBase.similar_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N","page":"ManifoldsBase.jl","title":"ManifoldsBase.similar_result_type","text":"similar_result_type(M::Manifold, f, args::NTuple{N,Any}) where N\n\nReturns type of element of the array that will represent the result of function f for manifold M on given arguments (passed at a tuple).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Vector-bundles-1","page":"Vector bundle","title":"Vector bundles","text":"","category":"section"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Vector bundle E is a manifold that is built on top of another manifold M (base space). It is characterized by a continuous function Pi colon E to M, such that for each point x in M the preimage of x by Pi, Pi^-1(x), has a structure of a vector space. These vector spaces are called fibers. Bundle projection can be performed using function bundle_projection.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Tangent bundle is a simple example of a vector bundle, swhere each fiber is the tangent space at the specified point x. An object representing a tangent bundle can be obtained using the constructor called TangentBundle.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Fibers of a vector bundle are represented by the type VectorBundleFibers. The important difference between functions operating on VectorBundle and VectorBundleFibers is that in the first case both a point on the underlying manifold and the vector are represented together (by a single argument) while in the second case only the vector part is present, while the point is supplied in a different argument where needed.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"VectorBundleFibers refers to the whole set of fibers of a vector bundle. There is also another type, VectorSpaceAtPoint, that represents a specific fiber at a given point. This distinction is made to reduce the need to repeatedly construct objects of type VectorSpaceAtPoint in certain usage scenarios.","category":"page"},{"location":"manifolds/vector_bundle.html#FVector-1","page":"Vector bundle","title":"FVector","text":"","category":"section"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"For cases where confusion between different types of vectors is possible, the type FVector can be used to express which type of vector space the vector belongs to. It is used for example in musical isomorphisms (the flat! and sharp! functions) that are used to go from a tangent space to cotangent space and vice versa.","category":"page"},{"location":"manifolds/vector_bundle.html#","page":"Vector bundle","title":"Vector bundle","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"VectorBundle.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/vector_bundle.html#Manifolds.FVector","page":"Vector bundle","title":"Manifolds.FVector","text":"FVector(type::VectorSpaceType, data)\n\nDecorator indicating that the vector data from a fiber of a vector bundle is of type type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundle","page":"Vector bundle","title":"Manifolds.VectorBundle","text":"VectorBundle(M::Manifold, type::VectorSpaceType)\n\nVector bundle on manifold M of type type.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorBundleFibers","page":"Vector bundle","title":"Manifolds.VectorBundleFibers","text":"VectorBundleFibers(VS::VectorSpaceType, M::Manifold)\n\nType representing a family of vector spaces (fibers) of a vector bundle over M with vector spaces of type VS. In contrast with VectorBundle, operations on VectorBundleFibers expect point-like and vector-like parts to be passed separately instead of being bundled together. It can be thought of as a representation of vector spaces from a vector bundle but without storing the point at which a vector space is attached (which is specified separately in various functions).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceAtPoint","page":"Vector bundle","title":"Manifolds.VectorSpaceAtPoint","text":"VectorSpaceAtPoint(fiber::VectorBundleFibers, x)\n\nA vector space (fiber type fiber of a vector bundle) at point x from the manifold fiber.M.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.VectorSpaceType","page":"Vector bundle","title":"Manifolds.VectorSpaceType","text":"VectorSpaceType\n\nAbstract type for tangent spaces, cotangent spaces, their tensor products, exterior products, etc.\n\nEvery vector space VS is supposed to provide:\n\na method of constructing vectors,\nbasic operations: addition, subtraction, multiplication by a scalar and negation (unary minus),\nzero_vector!(VS, v, x) to construct zero vectors at point x,\nsimilar(v, T) for vector v,\ncopyto!(v, w) for vectors v and w,\neltype(v) for vector v,\nvector_space_dimension(::VectorBundleFibers{<:typeof(VS)}) where VS.\n\nOptionally:\n\ninner product via inner (used to provide Riemannian metric on vector bundles),\nflat! and sharp!,\nnorm (by default uses inner),\nproject_vector! (for embedded vector spaces),\nrepresentation_size (if support for ProductArray is desired),\nbroadcasting for basic operations.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#LinearAlgebra.norm-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"LinearAlgebra.norm","text":"norm(B::VectorBundleFibers, x, v)\n\nNorm of the vector v from the vector space of type B.VS at point x from manifold B.M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.CotangentSpaceAtPoint-Tuple{Manifold,Any}","page":"Vector bundle","title":"Manifolds.CotangentSpaceAtPoint","text":"CotangentSpaceAtPoint(M::Manifold, x)\n\nReturn an object of type VectorSpaceAtPoint representing cotangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TangentSpaceAtPoint-Tuple{Manifold,Any}","page":"Vector bundle","title":"Manifolds.TangentSpaceAtPoint","text":"TangentSpaceAtPoint(M::Manifold, x)\n\nReturn an object of type VectorSpaceAtPoint representing tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.bundle_projection-Tuple{VectorBundle,Any}","page":"Vector bundle","title":"Manifolds.bundle_projection","text":"bundle_projection(B::VectorBundle, x::ProductRepr)\n\nProjection of point x from the bundle M to the base manifold. Returns the point on the base manifold B.M at which the vector part of x is attached.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.flat!-Tuple{Manifold,FVector,Any,FVector}","page":"Vector bundle","title":"Manifolds.flat!","text":"flat!(M::Manifold, v::FVector, x, w::FVector)\n\nCompute the flat isomorphism (one of the musical isomorphisms) of vector w from the vector space of type M at point x from manifold M.M.\n\nThe function can be used for example to transform vectors from the tangent bundle to vectors from the cotangent bundle flat colon TM to T^*M\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.sharp!-Tuple{Manifold,FVector,Any,FVector}","page":"Vector bundle","title":"Manifolds.sharp!","text":"sharp!(M::Manifold, v::FVector, x, w::FVector)\n\nCompute the sharp isomorphism (one of the musical isomorphisms) of vector w from the vector space of type M at point x from manifold M.M.\n\nThe function can be used for example to transform vectors from the cotangent bundle to vectors from the tangent bundle sharp colon T^*M to TM\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.vector_space_dimension-Tuple{VectorBundleFibers}","page":"Vector bundle","title":"Manifolds.vector_space_dimension","text":"vector_space_dimension(B::VectorBundleFibers)\n\nDimension of the vector space of type B.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.zero_vector!-Tuple{VectorBundleFibers,Any,Any}","page":"Vector bundle","title":"Manifolds.zero_vector!","text":"zero_vector!(B::VectorBundleFibers, v, x)\n\nSave the zero vector from the vector space of type B.VS at point x from manifold B.M to v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.zero_vector-Tuple{VectorBundleFibers,Any}","page":"Vector bundle","title":"Manifolds.zero_vector","text":"zero_vector(B::VectorBundleFibers, x)\n\nCompute the zero vector from the vector space of type B.VS at point x from manifold B.M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{VectorBundle,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(B::VectorBundle, x, y)\n\nDistance between points x and y from the vector bundle B over manifold B.VS (denoted M).\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B. Similarly, y = (p_y xi_y).\n\nThe distance is calculated as\n\nd_B(x y) = sqrtd_M(p_x p_y)^2 + d_F(xi_x xi_yto x)^2\n\nwhere d_M is the distance on manifold M, d_F is the distance between two vectors from the fiber F and xi_yto x is the result of parallel transport of vector xi_y to point p_x. The default behavior of vector_transport_to is used to compute the vector transport.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.distance-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.distance","text":"distance(B::VectorBundleFibers, x, v, w)\n\nDistance between vectors v and w from the vector space at point x from the manifold M.M, that is the base manifold of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.exp!-Tuple{VectorBundle,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.exp!","text":"exp!(B::VectorBundle, y, x, v)\n\nExponential map of tangent vector v at point x from vector bundle B over manifold B.VS (denoted M). The result overwrites the point y.\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\nThe tangent vector v = (xi_vM xi_vF) in T_xB where xi_vM is a tangent vector from the tangent space T_p_xM and xi_vF is a tangent vector from the tangent space T_xi_xF (isomorphic to F).\n\nThe exponential map is calculated as\n\nexp_x(v) = (exp_p_x(xi_vM) xi_exp)\n\nwhere xi_exp is the result of vector transport of xi_x + xi_vF to the point exp_p_x(xi_vM). The sum xi_x + xi_vF corresponds to the exponential map in the vector space F.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{VectorBundle,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundle, x, v, w)\n\nInner product of tangent vectors v and w at point x from the vector bundle B over manifold B.VS (denoted M).\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\nThe tangent vector v = (xi_vM xi_vF) in T_xB where xi_vM is a tangent vector from the tangent space T_p_xM and xi_vF is a tangent vector from the tangent space T_xi_xF (isomorphic to F). Similarly for the other tangent vector w = (xi_wM xi_wF) in T_xB.\n\nThe inner product is calculated as\n\nlangle v w rangle_B = langle xi_vM xi_wM rangle_M + langle xi_vF xi_wF rangle_F\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.inner-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.inner","text":"inner(B::VectorBundleFibers, x, v, w)\n\nInner product of vectors v and w from the vector space of type B.VS at point x from manifold B.M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.log!-Tuple{VectorBundle,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.log!","text":"log!(B::VectorBundle, v, x, y)\n\nLogarithmic map of the point y at point x from vector bundle B over manifold B.VS (denoted M). The result overwrites the tangent vector v.\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B. Similarly, y = (p_y xi_y).\n\nThe logarithmic map is calculated as\n\nlog_x(y) = (log_p_x(p_y) xi_log - xi_x)\n\nwhere xi_log is the result of vector transport of xi_y to the point p_x. The difference xi_log - xi_x corresponds to the logarithmic map in the vector space F.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project_point!-Tuple{VectorBundle,Any}","page":"Vector bundle","title":"ManifoldsBase.project_point!","text":"project_point!(B::VectorBundle, x)\n\nProject the point x from the ambient space of the vector bundle B over manifold B.VS (denoted M) to the vector bundle.\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x belongs to the ambient space of M and xi_x belongs to the ambient space of the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting the point p_x to the manifold M and then projecting the vector xi_x to the tangent space T_p_xM.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.project_tangent!-Tuple{VectorBundle,Any,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.project_tangent!","text":"project_tangent!(B::VectorBundle, w, x, v)\n\nProject the element v of the ambient space of the tangent space T_x B to the tangent space T_x B. The results overwrites w.\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\nThe vector x = (xi_vM xi_vF) where p_x belongs to the ambient space of T_p_xM and xi_vF belongs to the ambient space of the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\n\nThe projection is calculated by projecting xi_vM to tangent space T_p_xM and then projecting the vector xi_vF to the fiber F.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.zero_tangent_vector!-Tuple{VectorBundle,Any,Any}","page":"Vector bundle","title":"ManifoldsBase.zero_tangent_vector!","text":"zero_tangent_vector!(B::VectorBundle, v, x)\n\nZero tangent vector at point x from the vector bundle B over manifold B.VS (denoted M). The zero vector belongs to the space T_xB The result overwrites the tangent vector v.\n\nNotation:\n\nThe point x = (p_x xi_x) where p_x in M and xi_x belongs to the fiber F=pi^-1(p_x) of the vector bundle B where pi is the canonical projection of that vector bundle B.\n\nThe zero vector is calculated as\n\nmathbf0_x = (mathbf0_p_x mathbf0_F)\n\nwhere mathbf0_p_x is the zero tangent vector from T_p_xM and mathbf0_F is the zero element of the vector space F.\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.TensorProductType","page":"Vector bundle","title":"Manifolds.TensorProductType","text":"TensorProductType(spaces::VectorSpaceType...)\n\nVector space type corresponding to the tensor product of given vector space types.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/vector_bundle.html#Manifolds.project_vector!-Tuple{VectorBundleFibers,Any,Any,Any}","page":"Vector bundle","title":"Manifolds.project_vector!","text":"project_vector!(B::VectorBundleFibers, v, x, w)\n\nProject vector w from the vector space of type B.VS at point x and save the result to v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#Manifolds.similar_result_type-Union{Tuple{N}, Tuple{VectorBundleFibers,Any,Tuple{Vararg{Any,N}}}} where N","page":"Vector bundle","title":"Manifolds.similar_result_type","text":"similar_result_type(B::VectorBundleFibers, f, args::NTuple{N,Any}) where N\n\nReturns type of element of the array that will represent the result of function f for representing an operation with result in the vector space VS for manifold M on given arguments (passed at a tuple).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/vector_bundle.html#ManifoldsBase.similar_result-Tuple{VectorBundleFibers,Any,Vararg{Any,N} where N}","page":"Vector bundle","title":"ManifoldsBase.similar_result","text":"similar_result(B::VectorBundleFibers, f, x...)\n\nAllocates an array for the result of function f that is an element of the vector space of type B.VS on manifold B.M and arguments x... for implementing the non-modifying operation using the modifying operation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Product-Manifold-1","page":"Product manifold","title":"Product Manifold","text":"","category":"section"},{"location":"manifolds/product.html#","page":"Product manifold","title":"Product manifold","text":"Product manifold M = M_1 times M_2 times dots M_n of manifolds M_1 M_2 dots M_n. Points on the product manifold can be constructed using ProductRepr with canonical projections Pi_i colon M to M_i for i in 1 2 dots n provided by submanifold_component.","category":"page"},{"location":"manifolds/product.html#","page":"Product manifold","title":"Product manifold","text":"Modules = [Manifolds]\nPages = [\"ProductManifold.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"manifolds/product.html#Manifolds.ProductManifold","page":"Product manifold","title":"Manifolds.ProductManifold","text":"ProductManifold{TM<:Tuple, TRanges<:Tuple, TSizes<:Tuple} <: Manifold\n\nProduct manifold M_1 times M_2 times dots times M_n with product geometry. TRanges and TSizes statically define the relationship between representation of the product manifold and representations of point, tangent vectors and cotangent vectors of respective manifolds.\n\nConstructor\n\nProductManifold(M_1, M_2, ..., M_n)\n\ngenerates the product manifold M_1 times M_2 times dots times M_n. Alternatively, the same manifold can be contructed using the × operator: M_1 × M_2 × M_3.\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,AbstractArray{T,1} where T}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::AbstractVector)\n\nExtract the factor of the product manifold M indicated by indices in i. For example, for i equal to [1, 3] the product manifold constructed from the first and the third factor is returned.\n\nThis function is not type-stable, for better preformance use submanifold(M::ProductManifold, i::Val).\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,Integer}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Integer)\n\nExtract the ith factor of the product manifold M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.submanifold-Tuple{ProductManifold,Val}","page":"Product manifold","title":"Manifolds.submanifold","text":"submanifold(M::ProductManifold, i::Val)\n\nExtract the factor of the product manifold M indicated by indices in i. For example, for i equal to Val((1, 3)) the product manifold constructed from the first and the third factor is returned.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.InverseProductRetraction-Tuple{Vararg{AbstractInverseRetractionMethod,N} where N}","page":"Product manifold","title":"Manifolds.InverseProductRetraction","text":"InverseProductRetraction(inverse_retractions::AbstractInverseRetractionMethod...)\n\nProduct inverse retraction of inverse_retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#Manifolds.ProductFVectorDistribution","page":"Product manifold","title":"Manifolds.ProductFVectorDistribution","text":"ProductFVectorDistribution([type::VectorBundleFibers], [x], distrs...)\n\nGenerates a random vector at point x from vector space (a fiber of a tangent bundle) of type type using the product distribution of given distributions.\n\nVector space type and x can be automatically inferred from distributions distrs.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductPointDistribution","page":"Product manifold","title":"Manifolds.ProductPointDistribution","text":"ProductPointDistribution(M::ProductManifold, distributions)\n\nProduct distribution on manifold M, combined from distributions.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#Manifolds.ProductRetraction","page":"Product manifold","title":"Manifolds.ProductRetraction","text":"ProductRetraction(retractions::AbstractRetractionMethod...)\n\nProduct retraction of retractions. Works on ProductManifold.\n\n\n\n\n\n","category":"type"},{"location":"manifolds/product.html#ManifoldsBase.check_manifold_point-Tuple{ProductManifold,ProductRepr}","page":"Product manifold","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M::ProductManifold, x; kwargs...)\n\nCheck whether x is a valid point on the ProductManifold M.\n\nThe tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/product.html#ManifoldsBase.check_tangent_vector-Tuple{ProductManifold,ProductRepr,ProductRepr}","page":"Product manifold","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M::ProductManifold, x, v; kwargs... )\n\nCheck whether v is a tangent vector to x on the ProductManifold M, i.e. atfer check_manifold_point(M, x), and all projections to base manifolds must be respective tangent vectors.\n\nThe tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Euclidean-Space-1","page":"Euclidean","title":"Euclidean Space","text":"","category":"section"},{"location":"manifolds/euclidean.html#","page":"Euclidean","title":"Euclidean","text":"The Euclidean space mathbb R^n is a simple model space, since it has curvature constantly zero everywhere and hence nearly all operations simplify.","category":"page"},{"location":"manifolds/euclidean.html#","page":"Euclidean","title":"Euclidean","text":"Modules = [Manifolds]\nPages = [\"Euclidean.jl\"]\nOrder = [:type]","category":"page"},{"location":"manifolds/euclidean.html#Manifolds.Euclidean","page":"Euclidean","title":"Manifolds.Euclidean","text":"Euclidean{T<:Tuple} <: Manifold\n\nEuclidean vector space mathbb R^n.\n\nConstructor\n\nEuclidean(n)\n\ngenerates the n-dimensional vector space mathbb R^n.\n\nEuclidean(n₁,n₂,...,nᵢ)\n\ngenerates the n_1n_2cdotldots n_i-dimensional vector space mathbb R^n_1 n_2 ldots n_i, whose elements are interpreted as n_1 timesn_2timescdotstimes n_i arrays, e.g. for two parameters as matrices.\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#Manifolds.EuclideanMetric","page":"Euclidean","title":"Manifolds.EuclideanMetric","text":"EuclideanMetric <: RiemannianMetric\n\na general type for any manifold that employs the Euclidean Metric, for example the Euclidean manifold itself, or the Sphere, where every tangent space (as a plane in the embedding) uses this metric (in the embedding).\n\n\n\n\n\n","category":"type"},{"location":"manifolds/euclidean.html#","page":"Euclidean","title":"Euclidean","text":"Modules = [Manifolds]\nPages = [\"Euclidean.jl\"]\nOrder = [:function]","category":"page"},{"location":"manifolds/euclidean.html#LinearAlgebra.norm-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"LinearAlgebra.norm","text":"norm(M::Euclidean,x,v)\n\ncompute the norm of a tangent vector v at x on the Euclidean manifold M, i.e. since every tangent space can be identified with M itself in this case, just the (Frobenius) norm of v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.flat!-Tuple{Euclidean,FVector{Manifolds.CotangentSpaceType,TData} where TData,Any,FVector{Manifolds.TangentSpaceType,TData} where TData}","page":"Euclidean","title":"Manifolds.flat!","text":"flat!(M::Euclidean, v, x, w)\n\nsince cotangent and tangent vectors can directly be identified in the Euclidean case, this yields just the identity for a tangent vector w in the tangent space of x on M. The result is returned also in place in v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.normal_tvector_distribution-Union{Tuple{N}, Tuple{Euclidean{Tuple{N}},Any,Any}} where N","page":"Euclidean","title":"Manifolds.normal_tvector_distribution","text":"normal_tvector_distribution(S::Euclidean, x, σ)\n\nNormal distribution in ambient space with standard deviation σ projected to tangent space at x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.projected_distribution-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"Manifolds.projected_distribution","text":"projected_distribution(M::Euclidean, d, [x])\n\nWraps standard distribution d into a manifold-valued distribution. Generated points will be of similar type to x. By default, the type is not changed.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#Manifolds.sharp!-Tuple{Euclidean,FVector{Manifolds.TangentSpaceType,TData} where TData,Any,FVector{Manifolds.CotangentSpaceType,TData} where TData}","page":"Euclidean","title":"Manifolds.sharp!","text":"sharp!(M::Euclidean, v, x, w)\n\nsince cotangent and tangent vectors can directly be identified in the Euclidean case, this yields just the identity for a cotangent vector w in the tangent space of x on M. The result is returned also in place in v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.distance-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"ManifoldsBase.distance","text":"distance(M::Euclidean,x,y)\n\ncompute the Euclidean distance between two points on the Euclidean manifold M, i.e. for vectors it's just the norm of the difference, for matrices and higher order arrays, the matrix and ternsor Frobenius norm, respectively.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.exp!-Tuple{Euclidean,Any,Any,Any}","page":"Euclidean","title":"ManifoldsBase.exp!","text":"exp!(M::Euclidean,y, x, v)\n\ncompute the exponential map on the Euclidean manifold M from x in direction v in place, i.e. in y, which in this case is just\n\n    y = x + v\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.log!-Tuple{Euclidean,Any,Any,Any}","page":"Euclidean","title":"ManifoldsBase.log!","text":"log!(M::Euclidean, v, x, y)\n\ncompute the logarithmic map on the Euclidean manifold M from x tpo y, stored in the direction v in place, i.e. in v, which in this case is just\n\n    v = y - x\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.manifold_dimension-Union{Tuple{Euclidean{T}}, Tuple{T}} where T","page":"Euclidean","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Euclidean{T})\n\nreturns the manifold dimension of the Euclidean manifold M, i.e. the product of all array dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.project_point!-Tuple{Euclidean,Any}","page":"Euclidean","title":"ManifoldsBase.project_point!","text":"project_point!(M::Euclidean, x)\n\nproject an arbitrary point x onto the Euclidean manifold M, which is of course just the identity map.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.project_tangent!-Tuple{Euclidean,Any,Any,Any}","page":"Euclidean","title":"ManifoldsBase.project_tangent!","text":"project_tangent!(M::Euclidean, w, x, v)\n\nproject an arbitrary vector v into the tangent space of a point x on the Euclidean manifold M, which is just the identity, since any tangent space of M can be identified with all of M.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.representation_size-Union{Tuple{Euclidean{T}}, Tuple{T}} where T","page":"Euclidean","title":"ManifoldsBase.representation_size","text":"representation_size(M::Euclidean{T})\n\nreturns the array dimensions required to represent an element on the Euclidean manifold M, i.e. the vector of all array dimensions.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.vector_transport_to!-Tuple{Euclidean,Any,Any,Any,Any,ParallelTransport}","page":"Euclidean","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M::Euclidean, vto, x, v, y, ::ParallelTransport)\n\nparallel transport the vector v from the tangent space at x to the tangent space at y on the Euclidean manifold M, i.e. the in place w is just set to v.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/euclidean.html#ManifoldsBase.zero_tangent_vector!-Tuple{Euclidean,Any,Any}","page":"Euclidean","title":"ManifoldsBase.zero_tangent_vector!","text":"zero_tangent_vector!(M::Euclidean, v, x)\n\ncompute a zero vector in the tangent space of x on the Euclidean manifold M, whcih here is just a zero filled array the same size as the in place parameter v which is assumed to have the same size as x.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Symmetric-Positive-Definite-Matrices-1","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite Matrices","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"The symmetric positive definite matrices","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"mathcal P(n) = bigl A in mathbb R^ntimes n big A = A^mathrmT text and  x^mathrmTAx  0 text for  0neq x inmathbb R^n bigr","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"SymmetricPositiveDefinite","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite","page":"Symmetric Positive Definite","title":"Manifolds.SymmetricPositiveDefinite","text":"SymmetricPositiveDefinite{N} <: Manifold\n\nThe manifold of symmetric positive definite matrices, i.e.\n\nmathcal P(n) =\nbigl\nx in mathbb R^ntimes n \nxi^mathrmTxxi  0 text for all  xi in mathbb R^nbackslash0\nbigr\n\nConstructor\n\nSymmetricPositiveDefinite(n)\n\ngenerates the manifold mathcal P(n) subset mathbb R^ntimes n\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"can – for example – be illustrated as ellipsoids:  since the eigen values are all positive they can be taken as lengths of the axes of an ellipsoids while the directions are given by the eigenvectors.","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"(Image: An example set of data)","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"The manifold can be equipped with different metrics","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Common-and-Metric-Independent-functions-1","page":"Symmetric Positive Definite","title":"Common and Metric Independent functions","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"injectivity_radius(::SymmetricPositiveDefinite{N},a::Vararg{Any,N} where N) where N\ncheck_manifold_point(::SymmetricPositiveDefinite{N},x; kwargs...) where N\ncheck_tangent_vector(::SymmetricPositiveDefinite{N},x,v; kwargs...) where N\nmanifold_dimension(::SymmetricPositiveDefinite{N}) where N\nrepresentation_size(::SymmetricPositiveDefinite{N}) where N\nzero_tangent_vector(::SymmetricPositiveDefinite{N},x) where N\nzero_tangent_vector!(::SymmetricPositiveDefinite{N}, v, x) where N","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.injectivity_radius-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Vararg{Any,N} where N}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.injectivity_radius","text":"injectivity_radius(M)\n\nreturn the injectivity radius of the SymmetricPositiveDefinite. Since M  is a Hadamard manifold, the injectivity radius is infty.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.check_manifold_point-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.check_manifold_point","text":"check_manifold_point(M,x; kwargs...)\n\nchecks, whether x is a valid point on the SymmetricPositiveDefinite M, i.e. is a matrix of size (N,N), symmetric and positive definite. The tolerance for the second to last test can be set using the ´kwargs...`.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.check_tangent_vector-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.check_tangent_vector","text":"check_tangent_vector(M,x,v; kwargs... )\n\nchecks whether v is a tangent vector to x on the SymmetricPositiveDefinite M, i.e. atfer check_manifold_point(M,x), v has to be of same dimension as x and a symmetric matrix, i.e. this stores tangent vetors as elements of the corresponding Lie group. The tolerance for the last test can be set using the ´kwargs...`.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.manifold_dimension-Union{Tuple{SymmetricPositiveDefinite{N}}, Tuple{N}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.manifold_dimension","text":"manifold_dimension(M::Euclidean{T})\n\nreturns the manifold dimension of the Euclidean manifold M, i.e. the product of all array dimensions.\n\n\n\n\n\nmanifold_dimension(M)\n\nreturn the dimension of the real-valued Grassmann(n,k) manifold M, i.e.\n\nk(n-k)\n\n\n\nmanifold_dimension(M)\n\nreturn the dimension of the complex-valued Grassmann(n,k) manifold M, i.e.\n\n2k(n-k)\n\n\n\nmanifold_dimension(M::Rotations)\n\nreturns the dimension of the manifold mathrmSO(n), i.e. fracn(n-1)2.\n\n\n\nmanifold_dimension(S::Sphere)\n\nReturn the dimension of the manifold mathbb S^n, i.e. n.\n\n\n\nmanifold_dimension(M::SymmetricMatrices{n,Real})\n\nReturn the dimension of the SymmetricMatrices matrix M with real-valued entries, i.e. \n\n    fracn(n+1)2\n\n\n\nmanifold_dimension(M::SymmetricMatrices{n,Complex})\n\nReturn the dimension of the SymmetricMatrices matrix M with complex-valued entries, i.e. \n\n    n(n+1)\n\n\n\nmanifold_dimension(M)\n\nreturns the dimension of the manifold SymmetricPositiveDefinite mathcal P(n) nin mathbb N, i.e.\n\n    fracn(n+1)2\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.representation_size-Union{Tuple{SymmetricPositiveDefinite{N}}, Tuple{N}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.representation_size","text":"representation_size(M::Euclidean{T})\n\nreturns the array dimensions required to represent an element on the Euclidean manifold M, i.e. the vector of all array dimensions.\n\n\n\n\n\nrepresentation_size(M)\n\nreturns the size of an array representing an element on the SymmetricPositiveDefinite manifold M, i.e. ntimes n, the size of such a symmetric positive definite matrix on mathcal M = mathcal P(n).\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.zero_tangent_vector-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.zero_tangent_vector","text":"zero_tangent_vector(M,x)\n\nreturns the zero tangent vector in the tangent space of the symmetric positive definite matrix x on the SymmetricPositiveDefinite manifold M.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.zero_tangent_vector!-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.zero_tangent_vector!","text":"zero_tangent_vector!(M,v,x)\n\nreturns the zero tangent vector in the variable v from the tangent space of the symmetric positive definite matrix x on the SymmetricPositiveDefinite manifold M. THe result is returned also in place in the variable v.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Default-Metric:-Linear-Affine-Metric-1","page":"Symmetric Positive Definite","title":"Default Metric: Linear Affine Metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"LinearAffineMetric","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LinearAffineMetric","page":"Symmetric Positive Definite","title":"Manifolds.LinearAffineMetric","text":"LinearAffineMetric <: Metric\n\nThe linear affine metric is the metric for symmetric positive definite matrices, that employs matrix logarithms and exponentials, which yields a linear and affine metric.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"This metric is also the default metric, i.e. any call of the following functions with P=SymmetricPositiveDefinite(3) will result in MetricManifold(P,LinearAffineMetric())and hence yield the formulae described in this seciton.","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"distance(P::SymmetricPositiveDefinite{N},x,y) where N\nexp!(P::SymmetricPositiveDefinite{N}, y, x, v) where N\ninner(P::SymmetricPositiveDefinite, x, w, v)\nlog!(P::SymmetricPositiveDefinite{N}, v, x, y) where N\ntangent_orthonormal_basis(P::SymmetricPositiveDefinite{N},x,v) where N\nvector_transport_to!(P::SymmetricPositiveDefinite{N},vto, x, v, y, m::ParallelTransport) where N","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.distance","text":"distance(M,x,y)\n\ncomputes the distance on the SymmetricPositiveDefinite manifold between x and y, as a MetricManifold with LinearAffineMetric. The formula reads\n\nd_mathcal P(n)(xy) = lVert operatornameLog(x^-frac12yx^-frac12)rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertcdotrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.exp!-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.exp!","text":"exp!(M,y,x,v)\n\ncompute the exponential map from x with tangent vector v on the SymmetricPositiveDefinite as a MetricManifold with LinearAffineMetric and modify y. The formula reads\n\n    exp_x v = x^frac12operatornameExp(x^-frac12 v x^-frac12)x^frac12\n\nwhere operatornameExp denotes to the matrix exponential.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Tuple{SymmetricPositiveDefinite,Any,Any,Any}","page":"Symmetric Positive Definite","title":"ManifoldsBase.inner","text":"inner(M,x,v,w)\n\ncompute the inner product of v, w in the tangent space of x on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LinearAffineMetric. The formula reads\n\n(v w)_x = operatornametr(x^-1 v x^-1 w)\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.log!-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.log!","text":"log!(M,v,x,y)\n\ncompute the exponential map from x to y on the SymmetricPositiveDefinite as a MetricManifold with LinearAffineMetric and modify v. The formula reads\n\nlog_x y = x^frac12operatornameLog(x^-frac12 y x^-frac12)x^frac12\n\nwhere operatornameLog denotes to the matrix logarithm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.tangent_orthonormal_basis-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any}} where N","page":"Symmetric Positive Definite","title":"Manifolds.tangent_orthonormal_basis","text":"[Ξ,κ] = tangent_orthonormal_basis(M,x,v)\n\nreturns a orthonormal basis Ξ as a vector of tangent vectors (of length manifold_dimension of M) in the tangent space of x on the MetricManifold of SymmetricPositiveDefinite manifold M with LinearAffineMetric that diagonalizes the curvature tensor R(uv)w with eigenvalues κ and where the direction v has curvature 0.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.vector_transport_to!-Union{Tuple{N}, Tuple{SymmetricPositiveDefinite{N},Any,Any,Any,Any,ParallelTransport}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M,vto,x,v,y,::ParallelTransport)\n\ncompute the parallel transport on the SymmetricPositiveDefinite as a MetricManifold with the LinearAffineMetric. The formula reads\n\nP_xto y(v) = x^frac12\noperatornameExpbigl(\nfrac12x^-frac12log_x(y)x^-frac12\nbigr)\nx^-frac12v x^-frac12\noperatornameExpbigl(\nfrac12x^-frac12log_x(y)x^-frac12\nbigr)\nx^frac12\n\nwhere operatornameExp denotes the matrix exponential and log the logarithmic map on SymmetricPositiveDefinite (again with respect to the metric mentioned).\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Log-Euclidean-Metric-1","page":"Symmetric Positive Definite","title":"Log Euclidean Metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"LogEuclideanMetric","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LogEuclideanMetric","page":"Symmetric Positive Definite","title":"Manifolds.LogEuclideanMetric","text":"LogEuclideanMetric <: Metric\n\nThe LogEuclidean Metric consists of the Euclidean metric applied to all elements after mapping them into the Lie Algebra, i.e. performing a matrix logarithm beforehand.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"And we obtain the following functions","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"distance(P::MetricManifold{SymmetricPositiveDefinite{N},LogEuclideanMetric},x,y) where N","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogEuclideanMetric},Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.distance","text":"distance(M,x,y)\n\ncomputes the distance on the SymmetricPositiveDefinite manifold between x and y as a MetricManifold with LogEuclideanMetric. The formula reads\n\n    d_mathcal P(n)(xy) = lVert Log x - Log y rVert_mathrmF\n\nwhere operatornameLog denotes the matrix logarithm and lVertcdotrVert_mathrmF denotes the matrix Frobenius norm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Log-Cholesky-Metric-1","page":"Symmetric Positive Definite","title":"Log Cholesky Metric","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"LogCholeskyMetric","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Manifolds.LogCholeskyMetric","page":"Symmetric Positive Definite","title":"Manifolds.LogCholeskyMetric","text":"LogCholeskyMetric <: Metric\n\nThe Log-Cholesky metric imposes a metric based on the Cholesky decomposition as introduced by [Lin2019].\n\n[Lin2019]: Lin, Zenhua: \"Riemannian Geometry of Symmetric Positive Definite Matrices via Cholesky Decomposition\", arXiv: 1908.09326.\n\n\n\n","category":"type"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"distance(P::MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric},x,y) where N\nexp!(P::MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric}, y, x, v) where N\ninner(P::MetricManifold{SymmetricPositiveDefinite{N}, LogCholeskyMetric}, x, w, v) where N\nlog!(P::MetricManifold{SymmetricPositiveDefinite{N}, LogCholeskyMetric}, v, x, y) where N\nvector_transport_to!(M::MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric}, vto, x, v, y, ::ParallelTransport) where N","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.distance-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.distance","text":"distance(M,x,y)\n\ncomputes the distance on the manifold of SymmetricPositiveDefinite nmatrices, i.e. between two symmetric positive definite matrices x and y with respect to the LogCholeskyMetric. The formula reads\n\nd_mathcal P(n)(xy) = sqrt\n lVert lfloor l rfloor - lfloor k rfloor rVert_mathrmF^2\n + lVert log(operatornamediag(l)) - log(operatornamediag(k))rVert_mathrmF^2   \n\nwhere l and k are the cholesky factors of x and y, respectively, lfloorcdotrfloor denbotes the strictly lower triangular matrix of its argument, and lVertcdotrVert_mathrmF denotes the Frobenius norm.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.exp!-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.exp!","text":"exp!(M,y,x,v)\n\ncompute the exponential map on the SymmetricPositiveDefinite M with LogCholeskyMetric from x into direction v and store the result in y. The formula reads\n\nexp_x v = (exp_l w)(exp_l w)^mathrmT\n\nwhere exp_lw is the exponential map on CholeskySpace, l is the cholesky decomposition of x, w = l(l^-1vl^-mathrmT)_frac12, and (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.inner-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.inner","text":"inner(M,x,v,w)\n\ncompute the inner product of two matrices v, w in the tangent space of x on the SymmetricPositiveDefinite manifold M, as a MetricManifold with LogCholeskyMetric. The formula reads\n\n    (vw)_x = (p_l(w)p_l(v))_l\n\nwhere the right hand side is the inner product on the CholeskySpace, l is the cholesky factor of x, p_l(w) = l (l^-1wl^-mathrmT)_frac12, and (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.log!-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any,Any}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.log!","text":"log!(M,v,x,y)\n\ncomputes the logarithmic map o SymmetricPositiveDefinite M with respect to the LogCholeskyMetric. The formula can be adapted from the CholeskySpace as\n\nlog_xy = lw^mathrmT + wl^mathrmT\n\nwhere l is the colesky factor of x and w=log_lk for k the cholesky factor of y and the just mentioned logarithmic map is the one on CholeskySpace.\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#ManifoldsBase.vector_transport_to!-Union{Tuple{N}, Tuple{MetricManifold{SymmetricPositiveDefinite{N},LogCholeskyMetric},Any,Any,Any,Any,ParallelTransport}} where N","page":"Symmetric Positive Definite","title":"ManifoldsBase.vector_transport_to!","text":"vector_transport_to!(M,vto,x,v,y,::ParallelTransport)\n\nparallely transport the tangent vector v at x along the geodesic to y with respect to the SymmetricPositiveDefinite manifold M and LogCholeskyMetric. The parallel transport is based on the parallel transport on CholeskySpace: Let l and k denote the cholesky factors of x and y, respectively and w = l(l^-1vl^-mathrmT)_frac12, where (cdot)_frac12 denotes the lower triangular matrix with the diagonal multiplied by frac12. With u the parallel transport on CholeskySpace from l to k the formula hear reads\n\n    mathcal P_xto y(v) = ku^mathrmT + uk^mathrmT\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Statistics-1","page":"Symmetric Positive Definite","title":"Statistics","text":"","category":"section"},{"location":"manifolds/symmetricpositivedefinite.html#","page":"Symmetric Positive Definite","title":"Symmetric Positive Definite","text":"Modules = [Manifolds]\nPages   = [\"SymmetricPositiveDefinite.jl\"]\nOrder = [:function]\nFilter = t -> t === mean","category":"page"},{"location":"manifolds/symmetricpositivedefinite.html#Statistics.mean-Tuple{SymmetricPositiveDefinite,Vararg{Any,N} where N}","page":"Symmetric Positive Definite","title":"Statistics.mean","text":"mean(\n    M::SymmetricPositiveDefinite,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method = GeodesicInterpolation();\n    kwargs...,\n)\n\nCompute the Riemannian mean of x using GeodesicInterpolation.\n\n\n\n\n\n","category":"method"},{"location":"manifolds/symmetricpositivedefinite.html#Literature-1","page":"Symmetric Positive Definite","title":"Literature","text":"","category":"section"},{"location":"index.html#Manifolds-1","page":"Home","title":"Manifolds","text":"","category":"section"},{"location":"index.html#","page":"Home","title":"Home","text":"Package Manifolds aims to provide both a unified interface to define and use manifolds as well as a library of manifolds to use for your projects.","category":"page"},{"location":"index.html#","page":"Home","title":"Home","text":"Modules = [Manifolds, ManifoldsBase]\nPages = [\"Manifolds.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"index.html#Manifolds.AbstractEstimationMethod","page":"Home","title":"Manifolds.AbstractEstimationMethod","text":"AbstractEstimationMethod\n\nAbstract type for defining statistical estimation methods.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.PolarInverseRetraction","page":"Home","title":"Manifolds.PolarInverseRetraction","text":"PolarInverseRetraction\n\nInverse retraction on the rotations manifold using the polar method.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.PolarRetraction","page":"Home","title":"Manifolds.PolarRetraction","text":"PolarRetraction\n\nA retraction using the QR decomposition of a tangent vectors representation as a matrix.\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.QRInverseRetraction","page":"Home","title":"Manifolds.QRInverseRetraction","text":"QRInverseRetraction\n\nInverse retraction to the QRRetraction\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.QRRetraction","page":"Home","title":"Manifolds.QRRetraction","text":"QRRetraction\n\nA retraction using the QR decomposition of a tangent vectors representation as a matrix.\n\n\n\n\n\n","category":"type"},{"location":"index.html#Manifolds.hat-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.hat","text":"hat(M::Manifold, x, vⁱ)\n\nGiven a basis e_i on the tangent space at a point x and tangent component vector v^i, compute the equivalent vector representation v=v^i e_i, where Einstein summation notation is used:\n\nwedge v^i mapsto v^i e_i\n\nFor matrix manifolds, this converts a vector representation of the tangent vector to a matrix representation. The vee map is the hat map's inverse.\n\n\n\n","category":"method"},{"location":"index.html#Manifolds.vee-Tuple{Manifold,Any,Any}","page":"Home","title":"Manifolds.vee","text":"vee(M::Manifold, x, v)\n\nGiven a basis e_i on the tangent space at a point x and tangent vector v, compute the vector components v^i, such that v = v^i e_i, where Einstein summation notation is used:\n\nvee v^i e_i mapsto v^i\n\nFor matrix manifolds, this converts a  matrix representation of the tangent vector to a vector representation. The hat map is the vee map's inverse.\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics-1","page":"Statistics","title":"Statistics","text":"","category":"section"},{"location":"statistics.html#","page":"Statistics","title":"Statistics","text":"Modules = [Manifolds,ManifoldsBase]\nPages = [\"statistics.jl\"]\nOrder = [:type, :function]","category":"page"},{"location":"statistics.html#Manifolds.CyclicProximalPointEstimation","page":"Statistics","title":"Manifolds.CyclicProximalPointEstimation","text":"CyclicProximalPointEstimation <: AbstractEstimationMethod\n\nMethod for estimation using the cyclic proximal point technique.\n\n\n\n\n\n","category":"type"},{"location":"statistics.html#Manifolds.GeodesicInterpolation","page":"Statistics","title":"Manifolds.GeodesicInterpolation","text":"GeodesicInterpolation <: AbstractEstimationMethod\n\nRepeated weighted geodesic interpolation method for estimating the Riemannian center of mass.\n\nThe algorithm proceeds with the following simple online update:\n\nbeginaligned\nmu_1 = x_1\nt_k = fracw_ksum_i=1^k w_i\nmu_k = gamma_mu_k-1(x_k t_k)\nendaligned\n\nwhere x_k are points, w_k are weights, mu_k is the kth estimate of the mean, and gamma_x(y t) is the point at time t along the shortest_geodesic between points xy in mathcal M. The algorithm terminates when all x_k have been considered. In the Euclidean case, this exactly computes the weighted mean.\n\nThe algorithm has been shown to converge asymptotically with the sample size for the following manifolds equipped with their default metrics when all sampled points are in an open geodesic ball about the mean with corresponding radius (see GeodesicInterpolationWithinRadius):\n\nAll simply connected complete Riemannian manifolds with non-positive sectional curvature at radius infty [Cheng2016], in particular:\nEuclidean\nSymmetricPositiveDefinite [Ho2013]\nOther manifolds:\nSphere: fracpi2 [Salehian2015]\nGrassmann: fracpi4 [Chakraborty2015]\nStiefel/Rotations: fracpi2 sqrt 2 [Chakraborty2019]\n\nFor online variance computation, the algorithm additionally uses an analogous recursion to the weighted Welford algorithm [West1979].\n\n[Ho2013]: Ho J.; Cheng G.; Salehian H.; Vemuri B. C.; Recursive Karcher expectation estimators and geometric law of large numbers. Proceedings of the 16th International Conference on Artificial Intelligence and Statistics (2013), pp. 325–332. pdf.\n\n[Salehian2015]: Salehian H.; Chakraborty R.; Ofori E.; Vaillancourt D.; An efficient recursive estimator of the Fréchet mean on a hypersphere with applications to Medical Image Analysis. Mathematical Foundations of Computational Anatomy (2015). pdf.\n\n[Chakraborty2015]: Chakraborty R.; Vemuri B. C.; Recursive Fréchet Mean Computation on the Grassmannian and Its Applications to Computer Vision. Proceedings of the IEEE International Conference on Computer Vision (ICCV) (2015), pp. 4229-4237. doi: 10.1109/ICCV.2015.481, link.\n\n[Cheng2016]: Cheng G.; Ho J.; Salehian H.; Vemuri B. C.; Recursive Computation of the Fréchet Mean on Non-positively Curved Riemannian Manifolds with Applications. Riemannian Computing in Computer Vision. Springer, Cham (2016), pp. 21-43. doi: 10.1007/978-3-319-22957-7_2, pdf.\n\n[Chakraborty2019]: Chakraborty R.; Vemuri B. C.; Statistics on the (compact) Stiefel manifold: Theory and Applications. The Annals of Statistics (2019), 47(1), pp. 415-438. doi: 10.1214/18-AOS1692, arxiv: 1708.00045.\n\n[West1979]: West D. H. D.; Updating Mean and Variance Estimates: An Improved Method. Communications of the ACM (1979), 22(9), pp. 532–535. doi: 10.1145/359146.359153.\n\n\n\n","category":"type"},{"location":"statistics.html#Manifolds.GeodesicInterpolationWithinRadius","page":"Statistics","title":"Manifolds.GeodesicInterpolationWithinRadius","text":"GeodesicInterpolationWithinRadius{T} <: AbstractEstimationMethod\n\nEstimation of Riemannian center of mass using GeodesicInterpolation with fallback to GradientDescentEstimation if any points are outside of a geodesic ball of specified radius around the mean.\n\nConstructor\n\nGeodesicInterpolationWithinRadius(radius)\n\n\n\n\n\n","category":"type"},{"location":"statistics.html#Manifolds.GradientDescentEstimation","page":"Statistics","title":"Manifolds.GradientDescentEstimation","text":"GradientDescentEstimation <: AbstractEstimationMethod\n\nMethod for estimation using gradient descent.\n\n\n\n\n\n","category":"type"},{"location":"statistics.html#Statistics.mean!-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.mean!","text":"mean!(M::Manifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmean!(\n    M::Manifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the mean in-place in y.\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolationWithinRadius}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x using GeodesicInterpolationWithinRadius.\n\nSee mean for a description of kwargs.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.mean-Tuple{Manifold,AbstractArray{T,1} where T,AbstractArray{T,1} where T,GeodesicInterpolation}","page":"Statistics","title":"Statistics.mean","text":"mean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng=nothing,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nEstimate the Riemannian center of mass of x in an online fashion using repeated weighted geodesic interpolation. See GeodesicInterpolation for details.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered for computing the mean.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.mean","text":"mean(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\n\nCompute the (optionally weighted) Riemannian center of mass also known as Karcher mean of the vector x of points on the Manifold M, defined as the point that satisfies the minimizer\n\nargmin_yinmathcal M frac12 sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M^2(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance.\n\nIn the general case, the GradientDescentEstimation is used to compute the mean. However, this default may be overloaded for specific manifolds.\n\nmean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the mean using the specified method.\n\nmean(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::GradientDescentEstimation;\n    x0=x[1],\n    stop_iter=100,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nCompute the mean using the gradient descent scheme GradientDescentEstimation.\n\nOptionally, provide x0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe algorithm is further described in [Afsari2013].\n\n[Afsari2013]: Afsari, B; Tron, R.; Vidal, R.: On the Convergence of Gradient Descent for Finding the Riemannian Center of Mass, SIAM Journal on Control and Optimization (2013), 51(3), pp. 2230–2260, doi: 10.1137/12086282X, arxiv: 1201.0925\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.median!-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.median!","text":"median!(M::Manifold, y, x::AbstractVector[, w::AbstractWeights]; kwargs...)\nmedian!(\n    M::Manifold,\n    y,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\ncomputes the median in-place in y.\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.median","text":"median(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...)\n\nCompute the (optionally weighted) Riemannian median of the vector x of points on the Manifold M, defined as the point that satisfies the minimizer\n\nargmin_yinmathcal M frac1sum_i=1^n w_i sum_i=1^n w_imathrmd_mathcal M(yx_i)\n\nwhere mathrmd_mathcal M denotes the Riemannian distance. This function is nonsmooth (i.e nondifferentiable).\n\nIn the general case, the CyclicProximalPointEstimation is used to compute the median. However, this default may be overloaded for specific manifolds.\n\nmedian(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n)\n\nCompute the median using the specified method.\n\nmedian(\n    M::Manifold,\n    x::AbstractVector,\n    [w::AbstractWeights,]\n    method::CyclicProximalPointEstimation;\n    x0=x[1],\n    stop_iter=1000000,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n)\n\nCompute the median using CyclicProximalPointEstimation.\n\nOptionally, provide x0, the starting point (by default set to the first data point). stop_iter denotes the maximal number of iterations to perform and the kwargs... are passed to isapprox to stop, when the minimal change between two iterates is small. For more stopping criteria check the Manopt.jl package and use a solver therefrom.\n\nOptionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nThe algorithm is further described in [Bačák2014].\n\n[Bačák2014]: Bačák, M: Computing Medians and Means in Hadamard Spaces. SIAM Journal on Optimization (2014), 24(3), pp. 1542–1566, doi: 10.1137/140953393, arxiv: 1210.2145\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.std-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.std","text":"std(M, x, m=mean(M, x); corrected=true, kwargs...)\nstd(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)\n\ncompute the optionally weighted standard deviation of a Vector x of n data points on the Manifold M, i.e.\n\nsqrtfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.std. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true.\n\n\n\n","category":"method"},{"location":"statistics.html#Statistics.var-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"Statistics.var","text":"var(M, x, m=mean(M, x); corrected=true, kwargs...)\nvar(M, x, w::AbstractWeights, m=mean(M, x, w); corrected=false, kwargs...)\n\ncompute the (optionally weighted) variance of a Vector x of n data points on the Manifold M, i.e.\n\nfrac1c sum_i=1^n w_i d_mathcal M^2 (x_im)\n\nwhere c is a correction term, see Statistics.var. The mean of x can be specified as m, and the corrected variance can be activated by setting corrected=true. All further kwargs... are passed to the computation of the mean (if that is not provided).\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.kurtosis-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.kurtosis","text":"kurtosis(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the excess kurtosis of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.mean_and_std-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"StatsBase.mean_and_std","text":"mean_and_std(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, std)\n\nCompute the mean and the standard deviation std simultaneously.\n\nmean_and_std(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and standard deviation. To use a mean-specific method, call mean and then std.\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolationWithinRadius}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolationWithinRadius;\n    kwargs...,\n) -> (mean, var)\n\nUse repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nSee GeodesicInterpolationWithinRadius and mean_and_var for more information.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights,GeodesicInterpolation}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::GeodesicInterpolation;\n    shuffle_rng::Union{AbstractRNG,Nothing} = nothing,\n    retraction::AbstractRetractionMethod = ExponentialRetraction(),\n    inverse_retraction::AbstractInverseRetractionMethod = LogarithmicInverseRetraction(),\n    kwargs...,\n) -> (mean, var)\n\nUse the repeated weighted geodesic interpolation to estimate the mean. Simultaneously, use a Welford-like recursion to estimate the variance.\n\nIf shuffle_rng is provided, it is used to shuffle the order in which the points are considered. Optionally, pass retraction and inverse_retraction method types to specify the (inverse) retraction.\n\nSee GeodesicInterpolation for details on the geodesic interpolation method.\n\nnote: Note\nThe Welford algorithm for the variance is experimental and is not guaranteed to give accurate results except on Euclidean.\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.mean_and_var-Tuple{Manifold,Vararg{Any,N} where N}","page":"Statistics","title":"StatsBase.mean_and_var","text":"mean_and_var(M::Manifold, x::AbstractVector[, w::AbstractWeights]; kwargs...) -> (mean, var)\n\nCompute the mean and the variance simultaneously. See those functions for a description of the arguments.\n\nmean_and_var(\n    M::Manifold,\n    x::AbstractVector\n    [w::AbstractWeights,]\n    method::AbstractEstimationMethod;\n    kwargs...,\n) -> (mean, var)\n\nUse the method for simultaneously computing the mean and variance. To use a mean-specific method, call mean and then var.\n\n\n\n","category":"method"},{"location":"statistics.html#StatsBase.moment","page":"Statistics","title":"StatsBase.moment","text":"moment(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the kth central moment of points in x on manifold M. Optionally provide weights w and/or a precomputed mean.\n\n\n\n\n\n","category":"function"},{"location":"statistics.html#StatsBase.skewness-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}","page":"Statistics","title":"StatsBase.skewness","text":"skewness(M::Manifold, x::AbstractVector, k::Int[, w::AbstractWeights], m=mean(M, x[, w]))\n\nCompute the standardized skewness of points in x on manifold M. Optionally provide weights w and/or a precomputed mean m.\n\n\n\n\n\n","category":"method"},{"location":"statistics.html#Literature-1","page":"Statistics","title":"Literature","text":"","category":"section"}]
}
