<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Manifolds</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Manifolds</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href="index.html">Home</a><ul class="internal"><li><a class="toctext" href="#Interface-1">Interface</a></li><li><a class="toctext" href="#Decorators-1">Decorators</a></li></ul></li><li><span class="toctext">Manifolds</span><ul><li><span class="toctext">Basic manifolds</span><ul><li><a class="toctext" href="manifolds/euclidean.html">Euclidean</a></li><li><a class="toctext" href="manifolds/rotations.html">Rotations</a></li><li><a class="toctext" href="manifolds/sphere.html">Sphere</a></li></ul></li><li><span class="toctext">Combined manifolds</span><ul><li><a class="toctext" href="manifolds/product.html">Product manifold</a></li><li><a class="toctext" href="manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><span class="toctext">Manifold decorators</span><ul><li><a class="toctext" href="manifolds/array.html">Array manifold</a></li><li><a class="toctext" href="manifolds/metric.html">Metric manifold</a></li></ul></li></ul></li><li><a class="toctext" href="distributions.html">Distributions</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="lib/public.html">Public</a></li><li><a class="toctext" href="lib/internals.html">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href="index.html">Home</a></li></ul><a class="edit-page" href="https://github.com/JuliaNLSolvers/Manifolds.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Home</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Manifolds-1" href="#Manifolds-1">Manifolds</a></h1><p>Package <strong>Manifolds</strong> aims to provide both a unified interface to define and use manifolds as well as a library of manifolds to use for your projects.</p><h2><a class="nav-anchor" id="Interface-1" href="#Interface-1">Interface</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.IsDecoratorManifold" href="#Manifolds.IsDecoratorManifold"><code>Manifolds.IsDecoratorManifold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IsDecoratorManifold</code></pre><p>A <code>Trait</code> to mark a manifold as a decorator type. For any function that is only implemented for a decorator (i.e. a Manifold with <code>@traitimpl IsDecoratorManifold{M}</code>), a specific function should be implemented as a <code>@traitfn</code>, that transparently passes down through decorators, i.e.</p><pre><code class="language-none">@traitfn my_feature(M::MT, k...) where {MT; IsDecoratorManifold{MT}} = my_feature(M.manifold, k...)</code></pre><p>or the shorter version</p><pre><code class="language-none">@traitfn my_feature(M::::IsDecoratorManifold, k...) = my_feature(M.manifold, k...)</code></pre><p>such that decorators act just as pass throughs for other decorator functions and</p><pre><code class="language-none">my_feature(M::MyManifold, k...) = #... my explicit implementation</code></pre><p>then implements the feature itself.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.Manifold" href="#Manifolds.Manifold"><code>Manifolds.Manifold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Manifold</code></pre><p>A manifold type. The <code>Manifold</code> is used to dispatch to different exponential and logarithmic maps as well as other function on manifold.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}" href="#Base.exp-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">exp(M::Manifold, x, v, T::AbstractVector)</code></pre><p>Exponential map of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code> for each <code>t</code> in <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp-Tuple{Manifold,Any,Any}" href="#Base.exp-Tuple{Manifold,Any,Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">exp(M::Manifold, x, v, t=1)</code></pre><p>Exponential map of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Tuple{Manifold,Any,Any,Any}" href="#Base.isapprox-Tuple{Manifold,Any,Any,Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(M::Manifold, x, v, w; kwargs...)</code></pre><p>Check if vectors <code>v</code> and <code>w</code> tangent at <code>x</code> from manifold <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.isapprox-Tuple{Manifold,Any,Any}" href="#Base.isapprox-Tuple{Manifold,Any,Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">isapprox(M::Manifold, x, y; kwargs...)</code></pre><p>Check if points <code>x</code> and <code>y</code> from manifold <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Manifold,Any,Any}" href="#LinearAlgebra.norm-Tuple{Manifold,Any,Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">norm(M::Manifold, x, v)</code></pre><p>Norm of tangent vector <code>v</code> at point <code>x</code> from manifold <code>M</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.base_manifold" href="#Manifolds.base_manifold"><code>Manifolds.base_manifold</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">base_manifold(M::Manifold)</code></pre><p>Strip all decorators on <code>M</code>, returning the underlying topological manifold. Also used for vector bundles.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.distance-Tuple{Manifold,Any,Any}" href="#Manifolds.distance-Tuple{Manifold,Any,Any}"><code>Manifolds.distance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">distance(M::Manifold, x, y)</code></pre><p>Shortest distance between the points <code>x</code> and <code>y</code> on manifold <code>M</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.exp!-Tuple{Manifold,Any,Any,Any,Real}" href="#Manifolds.exp!-Tuple{Manifold,Any,Any,Any,Real}"><code>Manifolds.exp!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">exp!(M::Manifold, y, x, v, t=1)</code></pre><p>Exponential map of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code>. Result is saved to <code>y</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}" href="#Manifolds.geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}"><code>Manifolds.geodesic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">geodesic(M::Manifold, x, v, T::AbstractVector)</code></pre><p>Get the points for each <code>t</code> in <code>T</code> traveling from <code>x</code> along the geodesic with initial point <code>x</code> and velocity <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.geodesic-Tuple{Manifold,Any,Any,Real}" href="#Manifolds.geodesic-Tuple{Manifold,Any,Any,Real}"><code>Manifolds.geodesic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">geodesic(M::Manifold, x, v, t)</code></pre><p>Get the point at time <code>t</code> traveling from <code>x</code> along the geodesic with initial point <code>x</code> and velocity <code>v</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.geodesic-Tuple{Manifold,Any,Any}" href="#Manifolds.geodesic-Tuple{Manifold,Any,Any}"><code>Manifolds.geodesic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">geodesic(M::Manifold, x, v)</code></pre><p>Get the geodesic with initial point <code>x</code> and velocity <code>v</code>. The geodesic is the curve of constant velocity that is locally distance-minimizing. This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.injectivity_radius-Tuple{Manifold,Any,Manifolds.AbstractRetractionMethod}" href="#Manifolds.injectivity_radius-Tuple{Manifold,Any,Manifolds.AbstractRetractionMethod}"><code>Manifolds.injectivity_radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">injectivity_radius(M::Manifold, x, R::AbstractRetractionMethod)</code></pre><p>Distance <span>$d$</span> such that <code>retract(M, x, v, R)</code> is injective for all tangent vectors shorter than <span>$d$</span> (has a left inverse).</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.injectivity_radius-Tuple{Manifold,Any}" href="#Manifolds.injectivity_radius-Tuple{Manifold,Any}"><code>Manifolds.injectivity_radius</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">injectivity_radius(M::Manifold, x)</code></pre><p>Distance <span>$d$</span> such that <code>exp(M, x, v)</code> is injective for all tangent vectors shorter than <span>$d$</span> (has a left inverse).</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.injectivity_radius-Tuple{Manifold}" href="#Manifolds.injectivity_radius-Tuple{Manifold}"><code>Manifolds.injectivity_radius</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">injectivity_radius(M::Manifold, x)</code></pre><p>Infimum of the injectivity radii of all manifold points.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.inner-Tuple{Manifold,Any,Any,Any}" href="#Manifolds.inner-Tuple{Manifold,Any,Any,Any}"><code>Manifolds.inner</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inner(M::Manifold, x, v, w)</code></pre><p>Inner product of tangent vectors <code>v</code> and <code>w</code> at point <code>x</code> from manifold <code>M</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.inverse_retract!-Tuple{Manifold,Any,Any,Any,Manifolds.LogarithmicInverseRetraction}" href="#Manifolds.inverse_retract!-Tuple{Manifold,Any,Any,Any,Manifolds.LogarithmicInverseRetraction}"><code>Manifolds.inverse_retract!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inverse_retract!(M::Manifold, v, x, y, [method::AbstractInverseRetractionMethod=LogarithmicInverseRetraction()])</code></pre><p>Inverse retraction (cheaper, approximate version of logarithmic map) of points <code>x</code> and <code>y</code>. Result is saved to <code>y</code>.</p><p>Inverse retraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.inverse_retract-Tuple{Manifold,Any,Any,Manifolds.AbstractInverseRetractionMethod}" href="#Manifolds.inverse_retract-Tuple{Manifold,Any,Any,Manifolds.AbstractInverseRetractionMethod}"><code>Manifolds.inverse_retract</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">inverse_retract(M::Manifold, x, y, [method::AbstractInverseRetractionMethod])</code></pre><p>Inverse retraction (cheaper, approximate version of logarithmic map) of points <code>x</code> and <code>y</code> from manifold <code>M</code>.</p><p>Inverse retraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.is_manifold_point-Tuple{Manifold,Any}" href="#Manifolds.is_manifold_point-Tuple{Manifold,Any}"><code>Manifolds.is_manifold_point</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_manifold_point(M,x)</code></pre><p>check, whether <code>x</code> is a valid point on the <a href="index.html#Manifolds.Manifold"><code>Manifold</code></a> <code>M</code>. If it is not, an error is thrown. The default is to return <code>true</code>, i.e. if no checks are implmented, the assumption is to be optimistic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.is_tangent_vector-Tuple{Manifold,Any,Any}" href="#Manifolds.is_tangent_vector-Tuple{Manifold,Any,Any}"><code>Manifolds.is_tangent_vector</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_tangent_vector(M,x,v)</code></pre><p>check, whether <code>v</code> is a valid tangnt vector in the tangent plane of <code>x</code> on the <a href="index.html#Manifolds.Manifold"><code>Manifold</code></a> <code>M</code>. An implementation should first check <a href="manifolds/sphere.html#Manifolds.is_manifold_point-Union{Tuple{N}, Tuple{Sphere{N},Any}} where N"><code>is_manifold_point</code></a><code>(M,x)</code> and then validate <code>v</code>. If it is not a tangent vector an error should be thrown. The default is to return <code>true</code>, i.e. if no checks are implmented, the assumption is to be optimistic.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.manifold_dimension" href="#Manifolds.manifold_dimension"><code>Manifolds.manifold_dimension</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">manifold_dimension(M::Manifold)</code></pre><p>The dimension <span>$n$</span> of real space <span>$\mathbb R^n$</span> to which the neighborhood of each point of the manifold is homeomorphic.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.project_point!-Tuple{Manifold,Any}" href="#Manifolds.project_point!-Tuple{Manifold,Any}"><code>Manifolds.project_point!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">project_point!(M::Manifold, x)</code></pre><p>Project point from the ambient space onto the manifold <code>M</code>. The point <code>x</code> is modified. The function works only for selected embedded manifolds and is <em>not</em> required to return the closest point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.project_point-Tuple{Manifold,Any}" href="#Manifolds.project_point-Tuple{Manifold,Any}"><code>Manifolds.project_point</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">project_point(M::Manifold, x)</code></pre><p>Project point from the ambient space onto the manifold <code>M</code>. The point <code>x</code> is not modified. The function works only for selected embedded manifolds and is <em>not</em> required to return the closest point.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.project_tangent!-Tuple{Manifold,Any,Any,Any}" href="#Manifolds.project_tangent!-Tuple{Manifold,Any,Any,Any}"><code>Manifolds.project_tangent!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">project_tangent!(M::Manifold, w, x, v)</code></pre><p>Project ambient space representation of a vector <code>v</code> to a tangent vector at point <code>x</code> from the manifold <code>M</code>. The result is saved in vector <code>w</code>.</p><p>The function works only for selected embedded manifolds and is <em>not</em> required to return the closest vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.project_tangent-Tuple{Manifold,Any,Any}" href="#Manifolds.project_tangent-Tuple{Manifold,Any,Any}"><code>Manifolds.project_tangent</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">project_tangent(M::Manifold, x, v)</code></pre><p>Project ambient space representation of a vector <code>v</code> to a tangent vector at point <code>x</code> from the manifold <code>M</code>.</p><p>The function works only for selected embedded manifolds and is <em>not</em> required to return the closest vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.retract!-Tuple{Manifold,Any,Any,Any,Manifolds.ExponentialRetraction}" href="#Manifolds.retract!-Tuple{Manifold,Any,Any,Any,Manifolds.ExponentialRetraction}"><code>Manifolds.retract!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">retract!(M::Manifold, y, x, v, [t=1], [method::AbstractRetractionMethod=ExponentialRetraction()])</code></pre><p>Retraction (cheaper, approximate version of exponential map) of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code>. Result is saved to <code>y</code>.</p><p>Retraction method can be specified by the last argument. Please look at the documentation of respective manifolds for available methods.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.retract-Tuple{Manifold,Any,Any,Manifolds.AbstractRetractionMethod}" href="#Manifolds.retract-Tuple{Manifold,Any,Any,Manifolds.AbstractRetractionMethod}"><code>Manifolds.retract</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">retract(M::Manifold, x, v, [t=1], [method::AbstractRetractionMethod])</code></pre><p>Retraction (cheaper, approximate version of exponential map) of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}" href="#Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}"><code>Manifolds.shortest_geodesic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">shortest_geodesic(M::Manifold, x, y, T::AbstractVector)</code></pre><p>Get the points for each <code>t</code> in <code>T</code> traveling from <code>x</code> along a shortest geodesic connecting <code>x</code> and <code>y</code>, where <code>y</code> is reached at <code>t=1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any,Real}" href="#Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any,Real}"><code>Manifolds.shortest_geodesic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">shortest_geodesic(M::Manifold, x, y, t)</code></pre><p>Get the point at time <code>t</code> traveling from <code>x</code> along a shortest geodesic connecting <code>x</code> and <code>y</code>, where <code>y</code> is reached at <code>t=1</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any}" href="#Manifolds.shortest_geodesic-Tuple{Manifold,Any,Any}"><code>Manifolds.shortest_geodesic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">shortest_geodesic(M::Manifold, x, y)</code></pre><p>Get a geodesic with initial point <code>x</code> and point <code>y</code> at <code>t=1</code> whose length is the shortest path between the two points. When there are multiple shortest geodesics, there is no guarantee which will be returned. This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}" href="#Manifolds.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}"><code>Manifolds.vector_transport_direction!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vector_transport_direction!(M::Manifold, vto, x, v, vdir)</code></pre><p>Vector transport of vector <code>v</code> at point <code>x</code> in the direction indicated by the tangent vector <code>vdir</code> at point <code>x</code>. The result is saved to <code>vto</code>. By default, <code>exp</code> and <code>vector_transport_to!</code> are used.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.vector_transport_direction-Tuple{Manifold,Any,Any,Any}" href="#Manifolds.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>Manifolds.vector_transport_direction</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vector_transport_direction(M::Manifold, x, v, vdir)</code></pre><p>Vector transport of vector <code>v</code> at point <code>x</code> in the direction indicated by the tangent vector <code>vdir</code> at point <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}" href="#Manifolds.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}"><code>Manifolds.vector_transport_to!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, vto, x, v, y)</code></pre><p>Vector transport of vector <code>v</code> at point <code>x</code> to point <code>y</code>. The result is saved to <code>vto</code>. By default, <a href="index.html#Manifolds.project_tangent!-Tuple{Manifold,Any,Any,Any}"><code>project_tangent!</code></a> is used but this may change in the future.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.vector_transport_to-Tuple{Manifold,Any,Any,Any}" href="#Manifolds.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>Manifolds.vector_transport_to</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vector_transport_to(M::Manifold, x, v, y)</code></pre><p>Vector transport of vector <code>v</code> at point <code>x</code> to point <code>y</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.CoTVector" href="#Manifolds.CoTVector"><code>Manifolds.CoTVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">CoTVector</code></pre><p>Type for a cotangent vector of a manifold. While a <a href="index.html#Manifolds.Manifold"><code>Manifold</code></a> not necessarily requires this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of cotangent vectors and their types on a manifold.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.ExponentialRetraction" href="#Manifolds.ExponentialRetraction"><code>Manifolds.ExponentialRetraction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ExponentialRetraction</code></pre><p>Retraction using the exponential map.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.LogarithmicInverseRetraction" href="#Manifolds.LogarithmicInverseRetraction"><code>Manifolds.LogarithmicInverseRetraction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">LogarithmicInverseRetraction</code></pre><p>Inverse retraction using the logarithmic map.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.MPoint" href="#Manifolds.MPoint"><code>Manifolds.MPoint</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MPoint</code></pre><p>Type for a point on a manifold. While a <a href="index.html#Manifolds.Manifold"><code>Manifold</code></a> not necessarily requires this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of points on a manifold.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.OutOfInjectivityRadiusError" href="#Manifolds.OutOfInjectivityRadiusError"><code>Manifolds.OutOfInjectivityRadiusError</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">OutOfInjectivityRadiusError</code></pre><p>An error thrown when a function (for example logarithmic map or inverse retraction) is given arguments outside of its injectivity radius.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.TVector" href="#Manifolds.TVector"><code>Manifolds.TVector</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">TVector</code></pre><p>Type for a tangent vector of a manifold. While a <a href="index.html#Manifolds.Manifold"><code>Manifold</code></a> not necessarily requires this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification or even dispatch for different representations of tangent vectors and their types on a manifold.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.angle-Tuple{Manifold,Any,Any,Any}" href="#Base.angle-Tuple{Manifold,Any,Any,Any}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">angle(M::Manifold, x, v, w)</code></pre><p>Angle between tangent vectors <code>v</code> and <code>w</code> at point <code>x</code> from manifold <code>M</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.hat-Tuple{Manifold,Any,Any}" href="#Manifolds.hat-Tuple{Manifold,Any,Any}"><code>Manifolds.hat</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">hat(M::Manifold, x, vⁱ)</code></pre><p>Given a basis <span>$e_i$</span> on the tangent space at a point <span>$x$</span> and tangent component vector <span>$v^i$</span>, compute the equivalent vector representation <span>$v=v^i e_i$</span>, where Einstein summation notation is used:</p><div>\[\wedge: v^i \mapsto v^i e_i\]</div><p>For matrix manifolds, this converts a vector representation of the tangent vector to a matrix representation. The <a href="index.html#Manifolds.vee-Tuple{Manifold,Any,Any}"><code>vee</code></a> map is the <code>hat</code> map&#39;s inverse.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.representation_size" href="#Manifolds.representation_size"><code>Manifolds.representation_size</code></a> — <span class="docstring-category">Function</span>.</div><div><pre><code class="language-julia">representation_size(M::Manifold, [VS::VectorSpaceType])</code></pre><p>The size of array representing a point on manifold <code>M</code>, Representation sizes of tangent vectors can be obtained by calling the method with the second argument.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.similar_result-Tuple{Manifold,Any,Vararg{Any,N} where N}" href="#Manifolds.similar_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>Manifolds.similar_result</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">similar_result(M::Manifold, f, x...)</code></pre><p>Allocates an array for the result of function <code>f</code> on manifold <code>M</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p><p>Usefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.similar_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N" href="#Manifolds.similar_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N"><code>Manifolds.similar_result_type</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">similar_result_type(M::Manifold, f, args::NTuple{N,Any}) where N</code></pre><p>Returns type of element of the array that will represent the result of function <code>f</code> for manifold <code>M</code> on given arguments (passed at a tuple).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}" href="#Manifolds.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}"><code>Manifolds.vector_transport_along!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vector_transport_along!(M::Manifold, vto, x, v, c)</code></pre><p>Vector transport of vector <code>v</code> at point <code>x</code> along the curve <code>c</code> such that <code>c(0)</code> is equal to <code>x</code> to point <code>c(1)</code>. The result is saved to <code>vto</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.vector_transport_along-Tuple{Manifold,Any,Any,Any}" href="#Manifolds.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>Manifolds.vector_transport_along</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">vector_transport_along(M::Manifold, x, v, c)</code></pre><p>Vector transport of vector <code>v</code> at point <code>x</code> along the curve <code>c</code> such that <code>c(0)</code> is equal to <code>x</code> to point <code>c(1)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.vee-Tuple{Manifold,Any,Any}" href="#Manifolds.vee-Tuple{Manifold,Any,Any}"><code>Manifolds.vee</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">vee(M::Manifold, x, v)</code></pre><p>Given a basis <span>$e_i$</span> on the tangent space at a point <span>$x$</span> and tangent vector <span>$v$</span>, compute the vector components <span>$v^i$</span>, such that <span>$v = v^i e_i$</span>, where Einstein summation notation is used:</p><div>\[\vee: v^i e_i \mapsto v^i\]</div><p>For matrix manifolds, this converts a  matrix representation of the tangent vector to a vector representation. The <a href="index.html#Manifolds.hat-Tuple{Manifold,Any,Any}"><code>hat</code></a> map is the <code>vee</code> map&#39;s inverse.</p></div></section><h2><a class="nav-anchor" id="Decorators-1" href="#Decorators-1">Decorators</a></h2><ul><li><a href="manifolds/array.html#Array-manifold-1">Array manifold</a></li><li><a href="manifolds/metric.html#Metric-manifold-1">Metric manifold</a></li></ul><h3><a class="nav-anchor" id="Lie-Group-1" href="#Lie-Group-1">Lie Group</a></h3><footer><hr/><a class="next" href="manifolds/euclidean.html"><span class="direction">Next</span><span class="title">Euclidean</span></a></footer></article></body></html>
