<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Metric manifold · Manifolds</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Manifolds</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manifolds</span><ul><li><span class="toctext">Basic manifolds</span><ul><li><a class="toctext" href="euclidean.html">Euclidean</a></li><li><a class="toctext" href="rotations.html">Rotations</a></li><li><a class="toctext" href="sphere.html">Sphere</a></li></ul></li><li><span class="toctext">Combined manifolds</span><ul><li><a class="toctext" href="product.html">Product manifold</a></li><li><a class="toctext" href="vector_bundle.html">Vector bundle</a></li></ul></li><li><span class="toctext">Manifold decorators</span><ul><li><a class="toctext" href="array.html">Array manifold</a></li><li class="current"><a class="toctext" href="metric.html">Metric manifold</a><ul class="internal"></ul></li></ul></li></ul></li><li><a class="toctext" href="../distributions.html">Distributions</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public</a></li><li><a class="toctext" href="../lib/internals.html">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manifolds</li><li>Manifold decorators</li><li><a href="metric.html">Metric manifold</a></li></ul><a class="edit-page" href="https://github.com/JuliaNLSolvers/Manifolds.jl/blob/master/docs/src/manifolds/metric.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Metric manifold</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Metric-manifold-1" href="#Metric-manifold-1">Metric manifold</a></h1><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.HasMetric" href="#Manifolds.HasMetric"><code>Manifolds.HasMetric</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">HasMetric</code></pre><p>A <code>Trait</code> to mark a <code>Manifold</code> <code>M</code> as being shorthand for a <code>MetricManifold{M,G}</code> with metric <code>G</code>. This can be used to forward functions called on the <code>MetricManifold</code> to the already-imlemented functions for the <code>Manifold</code>.</p><p>For example,</p><pre><code class="language-none">@traitfn function my_feature(M::MMT, k...) where {MT&lt;:Manifold,
                                                  GT&lt;:Metric,
                                                  MMT&lt;:MetricManifold{MT,GT};
                                                  HasMetric{MT,GT}}
    return my_feature(M.manifold, k...)
end</code></pre><p>forwards the function <code>my_feature</code> from <code>M</code> to the already-implemented <code>my_feature</code> on the base manifold <code>M.manifold</code>. A manifold with a default metric can then be written</p><pre><code class="language-none">struct MyManifold{T} &lt;: Manifold end
struct MyMetric{S} &lt;: Metric end
@traitimpl HasMetric{MyManifold,MyMetric}</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.LorentzMetric" href="#Manifolds.LorentzMetric"><code>Manifolds.LorentzMetric</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">LorentzMetric &lt;: Metric</code></pre><p>Abstract type for Lorentz metrics, which have a single time dimension. These metrics assume the spacelike convention with the time dimension being last, giving the signature <span>$(++...+-)$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.Metric" href="#Manifolds.Metric"><code>Manifolds.Metric</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">Metric</code></pre><p>Abstract type for the pseudo-Riemannian metric tensor <span>$g$</span>, a family of smoothly varying inner products on the tangent space. See <a href="sphere.html#Manifolds.inner-Tuple{Sphere,Any,Any,Any}"><code>inner</code></a>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.MetricManifold" href="#Manifolds.MetricManifold"><code>Manifolds.MetricManifold</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">MetricManifold{M&lt;:Manifold,G&lt;:Metric} &lt;: Manifold</code></pre><p>Equip a manifold with a metric. Such a manifold is generally called pseudo- or semi-Riemannian. Each <code>MetricManifold</code> must implement <a href="metric.html#Manifolds.local_metric-Tuple{MetricManifold,Any}"><code>local_metric</code></a>.</p><p><strong>Constructor</strong></p><pre><code class="language-none">MetricManifold(manifold, metric)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.RiemannianMetric" href="#Manifolds.RiemannianMetric"><code>Manifolds.RiemannianMetric</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">RiemannianMetric &lt;: Metric</code></pre><p>Abstract type for Riemannian metrics, a family of positive definite inner products. The positive definite property means that for <span>$v \in T_x M$</span>, the inner product <span>$g(v, v) &gt; 0$</span> whenever <span>$v$</span> is not the zero vector.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.exp" href="#Base.exp"><code>Base.exp</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">exp(M::MetricManifold, x, v, args...)</code></pre><p>If the <a href="metric.html#Manifolds.HasMetric"><code>HasMetric</code></a> trait is defined for <code>M</code>, compute the exponential map of the base manifold. Otherwise, numerically integrate the exponential map assuming the Levi-Civita connection. See <a href="metric.html#Manifolds.solve_exp_ode-Tuple{MetricManifold,Any,Any,Any}"><code>solve_exp_ode</code></a></p><p>Currently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.christoffel_symbols_first-Tuple{MetricManifold,Any}" href="#Manifolds.christoffel_symbols_first-Tuple{MetricManifold,Any}"><code>Manifolds.christoffel_symbols_first</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">christoffel_symbols_first(M::MetricManifold, x)</code></pre><p>Compute the Christoffel symbols of the first kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)</p><div>\[\Gamma_{ijk} = \frac{1}{2} \left[g_{kj,i} + g_{ik,j} - g_{ij,k}\right],\]</div><p>where <span>$g_{ij,k}=\frac{\partial}{\partial x^k} g_{ij}$</span> is the coordinate derivative of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered <span>$(i,j,k)$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.christoffel_symbols_second-Tuple{MetricManifold,Any}" href="#Manifolds.christoffel_symbols_second-Tuple{MetricManifold,Any}"><code>Manifolds.christoffel_symbols_second</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">christoffel_symbols_second(M::MetricManifold, x)</code></pre><p>Compute the Christoffel symbols of the second kind in local coordinates. The Christoffel symbols are (in Einstein summation convention)</p><div>\[\Gamma^{l}_{ij} = g^{kl} \Gamma_{ijk},\]</div><p>where <span>$\Gamma_{ijk}$</span> are the Christoffel symbols of the first kind, and <span>$g^{kl}$</span> is the inverse of the local representation of the metric tensor. The dimensions of the resulting multi-dimensional array are ordered <span>$(l,i,j)$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.det_local_metric-Tuple{MetricManifold,Any}" href="#Manifolds.det_local_metric-Tuple{MetricManifold,Any}"><code>Manifolds.det_local_metric</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">det_local_metric(M::MetricManifold, x)</code></pre><p>Determinant of local matrix representation of the metric tensor <span>$g$</span></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.einstein_tensor-Tuple{MetricManifold,Any}" href="#Manifolds.einstein_tensor-Tuple{MetricManifold,Any}"><code>Manifolds.einstein_tensor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">einstein_tensor(M::MetricManifold, x)</code></pre><p>Compute the Einstein tensor of the manifold <code>M</code> at the point <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.gaussian_curvature-Tuple{MetricManifold,Any}" href="#Manifolds.gaussian_curvature-Tuple{MetricManifold,Any}"><code>Manifolds.gaussian_curvature</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">gaussian_curvature(M::MetricManifold, x)</code></pre><p>Compute the Gaussian curvature of the manifold <code>M</code> at the point <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.inverse_local_metric-Tuple{MetricManifold,Any}" href="#Manifolds.inverse_local_metric-Tuple{MetricManifold,Any}"><code>Manifolds.inverse_local_metric</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">inverse_local_metric(M::MetricManifold, x)</code></pre><p>Local matrix representation of the inverse metric (cometric) tensor, usually written <span>$g^{ij}$</span></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.local_metric-Tuple{MetricManifold,Any}" href="#Manifolds.local_metric-Tuple{MetricManifold,Any}"><code>Manifolds.local_metric</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">local_metric(M::MetricManifold, x)</code></pre><p>Local matrix representation at the point <code>x</code> of the metric tensor <span>$g$</span> on the manifold <code>M</code>, usually written <span>$g_{ij}$</span>. The matrix has the property that <span>$g(v, w)=v^T [g_{ij}] w = g_{ij} v^i w^j$</span>, where the latter expression uses Einstein summation convention.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.log_local_metric_density-Tuple{MetricManifold,Any}" href="#Manifolds.log_local_metric_density-Tuple{MetricManifold,Any}"><code>Manifolds.log_local_metric_density</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">log_local_metric_density(M::MetricManifold, x)</code></pre><p>Return the natural logarithm of the metric density <span>$\rho$</span> of <code>M</code> at <code>x</code>, which is given by <span>$\rho=\log \sqrt{|\det [g_{ij}]|}$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.metric-Tuple{MetricManifold}" href="#Manifolds.metric-Tuple{MetricManifold}"><code>Manifolds.metric</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">metric(M::MetricManifold)</code></pre><p>Get the metric <span>$g$</span> of the manifold <code>M</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.ricci_curvature-Tuple{MetricManifold,Any}" href="#Manifolds.ricci_curvature-Tuple{MetricManifold,Any}"><code>Manifolds.ricci_curvature</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ricci_curvature(M::MetricManifold, x)</code></pre><p>Compute the Ricci scalar curvature of the manifold <code>M</code> at the point <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.ricci_tensor-Tuple{MetricManifold,Any}" href="#Manifolds.ricci_tensor-Tuple{MetricManifold,Any}"><code>Manifolds.ricci_tensor</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ricci_tensor(M::MetricManifold, x)</code></pre><p>Compute the Ricci tensor, also known as the Ricci curvature tensor, of the manifold <code>M</code> at the point <code>x</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.riemann_tensor-Tuple{MetricManifold,Any}" href="#Manifolds.riemann_tensor-Tuple{MetricManifold,Any}"><code>Manifolds.riemann_tensor</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">riemann_tensor(M::MetricManifold, x)</code></pre><p>Compute the Riemann tensor <span>$R^l_{ijk}$</span>, also known as the Riemann curvature tensor, at the point <code>x</code>. The dimensions of the resulting multi-dimensional array are ordered <span>$(l,i,j,k)$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.local_metric_jacobian-Tuple{MetricManifold,Any}" href="#Manifolds.local_metric_jacobian-Tuple{MetricManifold,Any}"><code>Manifolds.local_metric_jacobian</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">local_metric_jacobian(M::MetricManifold, x)</code></pre><p>Get partial derivatives of the local metric of <code>M</code> at <code>x</code> with respect to the coordinates of <code>x</code>, <span>$\frac{\partial}{\partial x^k} g_{ij} = g_{ij,k}$</span>. The dimensions of the resulting multi-dimensional array are ordered <span>$(i,j,k)$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.solve_exp_ode-Tuple{MetricManifold,Any,Any,Any}" href="#Manifolds.solve_exp_ode-Tuple{MetricManifold,Any,Any,Any}"><code>Manifolds.solve_exp_ode</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">solve_exp_ode(M::MetricManifold,
              x,
              v,
              tspan;
              solver=AutoVern9(Rodas5()),
              kwargs...)</code></pre><p>Approximate the exponential map on the manifold over the provided timespan assuming the Levi-Civita connection by solving the ordinary differential equation</p><div>\[\frac{d^2}{dt^2} x^k + \Gamma^k_{ij} \frac{d}{dt} x_i \frac{d}{dt} x_j = 0,\]</div><p>where <span>$\Gamma^k_{ij}$</span> are the Christoffel symbols of the second kind, and the Einstein summation convention is assumed. The arguments <code>tspan</code> and <code>solver</code> follow the <code>OrdinaryDiffEq</code> conventions. <code>kwargs...</code> specify keyword arguments that will be passed to <code>OrdinaryDiffEq.solve</code>.</p><p>Currently, the numerical integration is only accurate when using a single coordinate chart that covers the entire manifold. This excludes coordinates in an embedded space.</p></div></section><footer><hr/><a class="previous" href="array.html"><span class="direction">Previous</span><span class="title">Array manifold</span></a><a class="next" href="../distributions.html"><span class="direction">Next</span><span class="title">Distributions</span></a></footer></article></body></html>
