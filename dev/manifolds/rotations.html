<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Rotations · Manifolds</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Manifolds</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../index.html">Home</a></li><li><span class="toctext">Manifolds</span><ul><li><span class="toctext">Basic manifolds</span><ul><li><a class="toctext" href="euclidean.html">Euclidean</a></li><li><a class="toctext" href="choleskyspace.html">Cholesky Space</a></li><li class="current"><a class="toctext" href="rotations.html">Rotations</a><ul class="internal"><li><a class="toctext" href="#Literature-1">Literature</a></li></ul></li><li><a class="toctext" href="sphere.html">Sphere</a></li><li><a class="toctext" href="symmetricpositivedefinite.html">Symmetric Positive Definite</a></li></ul></li><li><span class="toctext">Combined manifolds</span><ul><li><a class="toctext" href="power.html">Power manifold</a></li><li><a class="toctext" href="product.html">Product manifold</a></li><li><a class="toctext" href="vector_bundle.html">Vector bundle</a></li></ul></li><li><span class="toctext">Manifold decorators</span><ul><li><a class="toctext" href="array.html">Array manifold</a></li><li><a class="toctext" href="metric.html">Metric manifold</a></li></ul></li></ul></li><li><a class="toctext" href="../distributions.html">Distributions</a></li><li><span class="toctext">Library</span><ul><li><a class="toctext" href="../lib/public.html">Public</a></li><li><a class="toctext" href="../lib/internals.html">Internals</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manifolds</li><li>Basic manifolds</li><li><a href="rotations.html">Rotations</a></li></ul><a class="edit-page" href="https://github.com/JuliaNLSolvers/Manifolds.jl/blob/master/docs/src/manifolds/rotations.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Rotations</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Rotations-1" href="#Rotations-1">Rotations</a></h1><p>The manifold <span>$\mathrm{SO}(n)$</span> of orthogonal matrices with determinant <span>$+1$</span> in <span>$\mathbb R^{n\times n}$</span>, i.e.</p><div>\[\mathrm{SO}(n) = \bigl\{R \in \mathbb{R}^{n\times n} \big| RR^{\mathrm{T}} =
R^{\mathrm{T}}R = \mathrm{I}_n, \det(R) = 1 \bigr\}\]</div><p><span>$\mathrm{SO}(n)$</span> is a subgroup of the orthogonal group <span>$\mathrm{O}(n)$</span> and also known as the special orthogonal group or the set of rotations group.</p><p>Tangent vectors are represented by elements of the corresponding Lie algebra, which is the tangent space at the identity element. This convention allows for more efficient operations on tangent vectors. Tangent spaces at different points are different vector spaces.</p><p>Let <span>$L_R\colon \mathrm{SO}(n) \to \mathrm{SO}(n)$</span> where <span>$R \in \mathrm{SO}(n)$</span> be the left-multiplication by <span>$R$</span>, that is <span>$L_R(S) = RS$</span>. The tangent space at rotation <span>$R$</span>, <span>$T_R \mathrm{SO}(n)$</span>, is related to the tangent space at the identity rotation <span>$\mathrm{I}_n$</span> by the differential of <span>$L_R$</span> at identity, <span>$(\mathrm{d}L_R)_{\mathrm{I}_n} \colon T_{\mathrm{I}_n} \mathrm{SO}(n) \to T_R \mathrm{SO}(n)$</span>. For a tangent vector at the identity rotation <span>$v \in T_{\mathrm{I}_n} \mathrm{SO}(n)$</span> the matrix representation of the corresponding tangent vector <span>$w$</span> at a rotation <span>$R$</span> can be obtained by matrix multiplication: <span>$w=Rv \in T_R \mathrm{SO}(n)$</span>. You can compare the functions <a href="rotations.html#Manifolds.log!-Tuple{Manifolds.Rotations,Any,Any,Any}"><code>log!(::Manifolds.Rotations, v, x, y)</code></a> and <a href="choleskyspace.html#Manifolds.exp!-Union{Tuple{N}, Tuple{CholeskySpace{N},Any,Any,Any}} where N"><code>exp!(::Manifolds.Rotations, y, x, v)</code></a> to see how it works in practice.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.exp!-Tuple{Manifolds.Rotations{4},Any,Any,Any}" href="#Manifolds.exp!-Tuple{Manifolds.Rotations{4},Any,Any,Any}"><code>Manifolds.exp!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">exp!(M::Rotations{4}, y, x, v)</code></pre><p>Exponential map of tangent vector <code>v</code> at point <code>x</code> from <span>$\mathrm{SO}(4)$</span> manifold <code>M</code>. Result is saved to <code>y</code>.</p><p>The algorithm used is a more numerically stable form of those proposed in [<a href="#Gallier2003">Gallier, 2003</a>] and [<a href="#Andrica2013">Andrica, 2013</a>].</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.hat!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any}} where N" href="#Manifolds.hat!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any}} where N"><code>Manifolds.hat!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">hat!(M::Rotations, Ω, x, ω)</code></pre><p>Convert the unique tangent vector components <span>$\omega$</span> at point <span>$x$</span> on rotations group <span>$\mathrm{SO}(n)$</span> to the matrix representation <span>$\Omega$</span> of the tangent vector. See <a href="rotations.html#Manifolds.vee!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any}} where N"><code>vee!</code></a> for the conventions used.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.inner-Tuple{Manifolds.Rotations,Any,Any,Any}" href="#Manifolds.inner-Tuple{Manifolds.Rotations,Any,Any,Any}"><code>Manifolds.inner</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">inner(M, x, w, v)</code></pre><p>compute the inner product of the two tangent vectors <code>w, v</code> from the tangent plane at <code>x</code> on the special orthogonal space <code>M=</code><span>$\mathrm{SO}(n)$</span> using the restriction of the metric from the embedding, i.e.</p><div>\[(v, w)_x = \operatorname{tr}(v^T w)\]</div><p>.</p><p>Tangent vectors are represented by matrices.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.inverse_retract!-Tuple{Manifolds.Rotations,Any,Any,Any,Manifolds.PolarInverseRetraction}" href="#Manifolds.inverse_retract!-Tuple{Manifolds.Rotations,Any,Any,Any,Manifolds.PolarInverseRetraction}"><code>Manifolds.inverse_retract!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">inverse_retract!(M, v, x, y, ::PolarInverseRetraction)</code></pre><p>Compute a vector from the tagent space <span>$T_x\mathrm{SO}(n)$</span> of the point <code>x</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code> with which the point <code>y</code> can be reached by the <a href="rotations.html#Manifolds.PolarRetraction"><code>PolarRetraction</code></a> from the point <code>x</code> after time 1.</p><p>The formula reads <span>$v = -\frac{1}{2}(x^{\mathrm{T}}ys - (x^{\mathrm{T}}ys)^{\mathrm{T}})$</span></p><p>where <span>$s$</span> is the solution to the Sylvester equation</p><div>\[x^{\mathrm{T}}ys + s(x^{\mathrm{T}}y)^{\mathrm{T}} + 2\mathrm{I}_n = 0.\]</div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.inverse_retract!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any,Manifolds.QRInverseRetraction}} where N" href="#Manifolds.inverse_retract!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any,Manifolds.QRInverseRetraction}} where N"><code>Manifolds.inverse_retract!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">inverse_retract!(M::Rotations, x, y, ::QRInverseRetraction)</code></pre><p>Compute a vector from the tagent space <span>$T_x\mathrm{SO}(n)$</span> of the point <code>x</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code> with which the point <code>y</code> can be reached by the <a href="rotations.html#Manifolds.QRRetraction"><code>QRRetraction</code></a> from the point <code>x</code> after time 1.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.is_manifold_point-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any}} where N" href="#Manifolds.is_manifold_point-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any}} where N"><code>Manifolds.is_manifold_point</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_manifold_point(M,x; kwargs...)</code></pre><p>checks, whether <code>x</code> is a valid point on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>, i.e. is an array of size <a href="../index.html#Manifolds.manifold_dimension"><code>manifold_dimension</code></a><code>(M)</code> and represents a valid rotation. The tolerance for the last test can be set using the ´kwargs...`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.is_tangent_vector-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any}} where N" href="#Manifolds.is_tangent_vector-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any}} where N"><code>Manifolds.is_tangent_vector</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_tangent_vector(M,x,v; kwargs... )</code></pre><p>checks whether <code>v</code> is a tangent vector to <code>x</code> on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> space <code>M</code>, i.e. after <a href="sphere.html#Manifolds.is_manifold_point-Union{Tuple{N}, Tuple{Sphere{N},Any}} where N"><code>is_manifold_point</code></a><code>(M,x)</code>, <code>v</code> has to be of same dimension as <code>x</code> and orthogonal to <code>x</code>. The tolerance for the last test can be set using the ´kwargs...`.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.log!-Tuple{Manifolds.Rotations,Any,Any,Any}" href="#Manifolds.log!-Tuple{Manifolds.Rotations,Any,Any,Any}"><code>Manifolds.log!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">log!(M::Rotations, v, x, y)</code></pre><p>compute the logarithmic map on the <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> manifold <code>M</code><span>$=\mathrm{SO}(n)$</span>, which is given by</p><div>\[\log_{x} y =
  \frac{1}{2} \bigl(\operatorname{Log}(x^{\mathrm{T}}y)
  - (\operatorname{Log} x^{\mathrm{T}}y)^{\mathrm{T}}),\]</div><p>where <span>$\operatorname{Log}$</span> denotes the matrix logarithm, and save the result to <code>v</code>.</p><p>For antipodal rotations the function returns one of the tangent vectors that point at <code>y</code>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.manifold_dimension-Union{Tuple{Manifolds.Rotations{N}}, Tuple{N}} where N" href="#Manifolds.manifold_dimension-Union{Tuple{Manifolds.Rotations{N}}, Tuple{N}} where N"><code>Manifolds.manifold_dimension</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">manifold_dimension(M::Rotations)</code></pre><p>returns the dimension of the manifold <span>$\mathrm{SO}(n)$</span>, i.e. <span>$\frac{n(n-1)}{2}$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.retract!-Tuple{Manifolds.Rotations,Any,Any,Any,Manifolds.PolarRetraction}" href="#Manifolds.retract!-Tuple{Manifolds.Rotations,Any,Any,Any,Manifolds.PolarRetraction}"><code>Manifolds.retract!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">retract_polar!(M::Rotations, y, x, v, method::PolarRetraction)</code></pre><p>Compute the SVD-based retraction <a href="rotations.html#Manifolds.PolarRetraction"><code>PolarRetraction</code></a>, a second-order approximation of the exponential map.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.retract!-Union{Tuple{T}, Tuple{Manifolds.Rotations,AbstractArray{T,N} where N,Any,Any,Manifolds.QRRetraction}} where T" href="#Manifolds.retract!-Union{Tuple{T}, Tuple{Manifolds.Rotations,AbstractArray{T,N} where N,Any,Any,Manifolds.QRRetraction}} where T"><code>Manifolds.retract!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">retract!(M, y, x, v, method::QRRetraction)</code></pre><p>This QR-based retraction is a first-order approximation of the exponential map.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.vee!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any}} where N" href="#Manifolds.vee!-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Any,Any}} where N"><code>Manifolds.vee!</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">vee!(M::Rotations, ω, x, Ω)</code></pre><p>Extract the unique tangent vector components <span>$\omega$</span> at point <span>$x$</span> on rotations group <span>$\mathrm{SO}(n)$</span> from the matrix representation <span>$\Omega$</span> of the tangent vector.</p><p>The basis on the Lie algebra <span>$\mathfrak{so}(n)$</span> is chosen such that for <span>$\mathrm{SO}(2)$</span>, <span>$\omega=\theta=\Omega_{21}$</span> is the angle of rotation, and for <span>$\mathrm{SO}(3)$</span>, <span>$\omega = (\Omega_{32}, \Omega_{13}, \Omega_{21}) = \theta u$</span> is the angular velocity and axis-angle representation, where <span>$u$</span> is the unit vector along the axis of rotation.</p><p>For <span>$\mathrm{SO}(n)$</span> where <span>$n \ge 4$</span>, the additional elements of <span>$\omega$</span> are <span>$\omega_{i (i - 3)/2 + j + 1} = \Omega_{ij}$</span>, for <span>$i \in [4, n], j \in [1,i)$</span>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.NormalRotationDistribution" href="#Manifolds.NormalRotationDistribution"><code>Manifolds.NormalRotationDistribution</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">NormalRotationDistribution(M::Rotations, d::Distribution, x::TResult)</code></pre><p>Distribution that returns a random point on the manifold <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code>. Random point is generated using base distribution <code>d</code> and the type of the result is adjusted to <code>TResult</code>.</p><p>See <a href="rotations.html#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Real}} where N"><code>normal_rotation_distribution</code></a> for details.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.PolarInverseRetraction" href="#Manifolds.PolarInverseRetraction"><code>Manifolds.PolarInverseRetraction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PolarInverseRetraction</code></pre><p>Inverse retraction on the rotations manifold using the polar method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.PolarRetraction" href="#Manifolds.PolarRetraction"><code>Manifolds.PolarRetraction</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">PolarRetraction</code></pre><p>Retraction on the rotations manifold using the polar method. This SVD-based retraction is a second-order approximation of the exponential map. Let</p><div>\[USV = x + xv\]</div><p>be the singular value decomposition, then the formula reads</p><div>\[\operatorname{retr}_x v = UV^\mathrm{T}\]</div><p>Retraction is performed by the function <a href="rotations.html#Manifolds.retract!-Tuple{Manifolds.Rotations,Any,Any,Any,Manifolds.PolarRetraction}"><code>retract!(::Rotations, y, x, v, ::PolarRetraction)</code></a></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.QRInverseRetraction" href="#Manifolds.QRInverseRetraction"><code>Manifolds.QRInverseRetraction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">QRInverseRetraction</code></pre><p>Inverse retraction on the rotations manifold using the QR method.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.QRRetraction" href="#Manifolds.QRRetraction"><code>Manifolds.QRRetraction</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">QRRetraction</code></pre><p>Retraction on the rotations manifold using the QR method, a first order approximation of the exponential map.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.Rotations" href="#Manifolds.Rotations"><code>Manifolds.Rotations</code></a> — <span class="docstring-category">Type</span>.</div><div><pre><code class="language-julia">Rotations{N} &lt;: Manifold</code></pre><p>Special orthogonal manifold <span>$\mathrm{SO}(n)$</span> represented by <span>$n\times n$</span> real-valued orthogonal matrices with determinant <span>$+1$</span>.</p><p><strong>Constructor</strong></p><pre><code class="language-none">Rotations(n)</code></pre><p>generates the <span>$\mathrm{SO}(n) \subset \mathbb R^{n\times n}$</span></p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}" href="#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}"><code>Manifolds.angles_4d_skew_sym_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">angles_4d_skew_sym_matrix(A)</code></pre><p>The Lie algebra of <span>$\mathrm{SO}(4)$</span> consists of 4x4 skew-symmetric matrices. The unique imaginary components of their eigenvalues are the angles of the two plane rotations. This function computes these more efficiently than <code>eigvals</code>.</p><p>By convention, the returned values are sorted in decreasing order (corresponding to the same ordering of <em>angles</em> as <a href="rotations.html#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}"><code>cos_angles_4d_rotation_matrix</code></a>).</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}" href="#Manifolds.cos_angles_4d_rotation_matrix-Tuple{Any}"><code>Manifolds.cos_angles_4d_rotation_matrix</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">cos_angles_4d_rotation_matrix(R)</code></pre><p>4D rotations can be described by two orthogonal planes that are unchanged by the action of the rotation (vectors within a plane rotate only within the plane). The cosines of the two angles of rotation about these planes may be obtained from the distinct real parts of the eigenvalues of the rotation matrix. This function computes these more efficiently by solving the system</p><div>\[\begin{aligned}
\cos\alpha + \cos\beta &amp;= \frac{1}{2} \operatorname{tr}(R)\\
\cos\alpha + \cos\beta &amp;= \frac{1}{8} \operatorname{tr}(R)^2
                           - \frac{1}{16} \operatorname{tr}((R - R^T)^2) - 1.
\end{aligned}\]</div><p>By convention, the returned values are sorted in increasing order. See <a href="rotations.html#Manifolds.angles_4d_skew_sym_matrix-Tuple{Any}"><code>angles_4d_skew_sym_matrix</code></a>. For derivation of the above, see <a href="#Gallier2003">[Gallier, 2013]</a>.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Real}} where N" href="#Manifolds.normal_rotation_distribution-Union{Tuple{N}, Tuple{Manifolds.Rotations{N},Any,Real}} where N"><code>Manifolds.normal_rotation_distribution</code></a> — <span class="docstring-category">Method</span>.</div><div><pre><code class="language-julia">normal_rotation_distribution(M::Rotations, x, σ::Real)</code></pre><p>return a random point on the manifold <a href="rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <code>M</code> by generating a (Gaussian) random orthogonal matrix with determinant <span>$+1$</span>. Let</p><div>\[QR = A\]</div><p>be the QR decomposition of a random matrix <span>$A$</span>, then the formula reads</p><div>\[x = QD\]</div><p>where <span>$D$</span> is a diagonal matrix with the signs of the diagonal entries of <span>$R$</span>, i.e.</p><div>\[D_{ij}=\begin{cases} \operatorname{sgn}(R_{ij}) &amp; \text{if} \; i=j \\ 0 &amp; \, \text{otherwise} \end{cases}.\]</div><p>It can happen that the matrix gets -1 as a determinant. In this case, the first and second columns are swapped.</p><p>The argument <code>x</code> is used to determine the type of returned points.</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Manifolds.normal_tvector_distribution-Tuple{Manifolds.Rotations,Any,Any}" href="#Manifolds.normal_tvector_distribution-Tuple{Manifolds.Rotations,Any,Any}"><code>Manifolds.normal_tvector_distribution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">normal_tvector_distribution(M::Rotations, x, σ)</code></pre><p>Normal distribution in ambient space with standard deviation <code>σ</code> projected to tangent space at <code>x</code>.</p></div></div></section><h2><a class="nav-anchor" id="Literature-1" href="#Literature-1">Literature</a></h2><ul>
  <li id="Gallier2003">[<a>Gallier, 2003</a>]
    J. Gallier and D. Xu, “Computing exponentials of skew-symmetric matrices
    and logarithms of orthogonal matrices,” <i>International Journal of
    Robotics and Automation</i>, vol. 18, no. 1, pp. 10–20, 2003.
  </li>
  <li id="Andrica2013">[<a>Andrica, 2013</a>]
    D. Andrica and R.-A. Rohan, “Computing the Rodrigues coefficients of the
    exponential map of the Lie groups of matrices,” <i>Balkan Journal of
    Geometry and Its Applications</i>, vol. 18, no. 2, pp. 1–10, 2013.
  </li>
</ul><footer><hr/><a class="previous" href="choleskyspace.html"><span class="direction">Previous</span><span class="title">Cholesky Space</span></a><a class="next" href="sphere.html"><span class="direction">Next</span><span class="title">Sphere</span></a></footer></article></body></html>
