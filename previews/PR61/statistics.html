<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Statistics · Manifolds</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Manifolds</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li><a class="tocitem" href="interface.html">ManifoldsBase.jl</a></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="manifolds/choleskyspace.html">Cholesky Space</a></li><li><a class="tocitem" href="manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="manifolds/symmetricpositivedefinite.html">Symmetric Positive Definite</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/array.html">Array manifold</a></li><li><a class="tocitem" href="manifolds/metric.html">Metric manifold</a></li></ul></li></ul></li><li class="is-active"><a class="tocitem" href="statistics.html">Statistics</a><ul class="internal"><li><a class="tocitem" href="#Literature-1"><span>Literature</span></a></li></ul></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/public.html">Public</a></li><li><a class="tocitem" href="lib/internals.html">Internals</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="statistics.html">Statistics</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="statistics.html">Statistics</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaNLSolvers/Manifolds.jl/blob/master/docs/src/statistics.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Statistics-1"><a class="docs-heading-anchor" href="#Statistics-1">Statistics</a><a class="docs-heading-anchor-permalink" href="#Statistics-1" title="Permalink"></a></h1><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean!-Tuple{Manifold,Any,AbstractArray{T,1} where T,StatsBase.AbstractWeights,Manifolds.GeodesicInterpolationMethod}" href="#Statistics.mean!-Tuple{Manifold,Any,AbstractArray{T,1} where T,StatsBase.AbstractWeights,Manifolds.GeodesicInterpolationMethod}"><code>Statistics.mean!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean!(
    M::Manifold,
    y,
    x::AbstractVector,
    w::AbstractWeights,
    method::GeodesicInterpolationMethod;
    shuffle_rng=nothing,
    kwargs...,
)</code></pre><p>Estimate the Riemannian center of mass of <code>x</code> in an online fashion using repeated weighted geodesic interpolation. See <a href="statistics.html#Manifolds.GeodesicInterpolationMethod"><code>GeodesicInterpolationMethod</code></a> for details.</p><p>If <code>shuffle_rng</code> is provided, it is used to shuffle the order in which the points are considered for computing the mean.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean!-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.mean!-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.mean!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean!(M::Manifold, y, x::AbstractVector, [w::AbstractWeights]; kwargs...)
mean!(M::Manifold, y, x::AbstractVector, [w::AbstractWeights], method::AbstractMethod; kwargs...)</code></pre><p>Compute the <a href="manifolds/rotations.html#Statistics.mean-Tuple{Manifolds.Rotations,Vararg{Any,N} where N}"><code>mean</code></a> in-place in <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.mean-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean(M::Manifold, x::AbstractVector, [w::AbstractWeights]; kwargs...)</code></pre><p>Compute the (optionally weighted) Riemannian center of mass also known as Karcher mean of the vector <code>x</code> of points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, defined as the point that satisfies the minimizer</p><div>\[\argmin_{y\in\mathcal M} \frac{1}{2 \sum_{i=1}^n w_i} \sum_{i=1}^n w_i\mathrm{d}_{\mathcal M}^2(y,x_i),\]</div><p>where <span>$\mathrm{d}_{\mathcal M}$</span> denotes the Riemannian <a href="interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>distance</code></a>.</p><p>In the general case, the <a href="index.html#Manifolds.GradientMethod"><code>GradientMethod</code></a> is used to compute the mean. However, this default may be overloaded for specific manifolds.</p><pre><code class="language-none">mean(M::Manifold, x::AbstractVector, [w::AbstractWeights], method::AbstractMethod; kwargs...)</code></pre><p>Compute the mean using the specified <code>method</code>.</p><pre><code class="language-none">mean(
    M::Manifold,
    x::AbstractVector,
    w::AbstractWeights,
    method::GradientMethod;
    x0=x[1],
    stop_iter=100,
    kwargs...
)</code></pre><p>Compute the mean using the gradient descent scheme <a href="index.html#Manifolds.GradientMethod"><code>GradientMethod</code></a>.</p><p>Optionally, provide <code>x0</code>, the starting point (by default set to the first data point). Set <code>x0</code> to <code>nothing</code> to use the intitial value of <code>y</code> as the starting point. <code>stop_iter</code> denotes the maximal number of iterations to perform and the <code>kwargs...</code> are passed to <a href="interface.html#Base.isapprox-Tuple{Manifold,Any,Any,Any}"><code>isapprox</code></a> to stop, when the minimal change between two iterates is small. For more stopping criteria check the <a href="https://manoptjl.org"><code>Manopt.jl</code></a> package and use a solver therefrom.</p><p>The algorithm is further described in <a href="#Afsari2013">[Afsari et al, 2013]</a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.median!-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.median!-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.median!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">median!(M::Manifold, y, x::AbstractVector, [w::AbstractWeights]; kwargs...)
median!(M::Manifold, y, x::AbstractVector, [w::AbstractWeights], method::AbstractMethod; kwargs...)</code></pre><p>computes the <a href="statistics.html#Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}"><code>median</code></a> in-place in <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}" href="#Statistics.median-Tuple{Manifold,Vararg{Any,N} where N}"><code>Statistics.median</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">median(M::Manifold, x::AbstractVector, [w::AbstractWeights]; kwargs...)</code></pre><p>Compute the (optionally weighted) Riemannian median of the vector <code>x</code> of points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, defined as the point that satisfies the minimizer</p><div>\[\argmin_{y\in\mathcal M} \frac{1}{\sum_{i=1}^n w_i} \sum_{i=1}^n w_i\mathrm{d}_{\mathcal M}(y,x_i),\]</div><p>where <span>$\mathrm{d}_{\mathcal M}$</span> denotes the Riemannian <a href="interface.html#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>distance</code></a>. This function is nonsmooth (i.e nondifferentiable).</p><p>In the general case, the <a href="index.html#Manifolds.CyclicProximalPointMethod"><code>CyclicProximalPointMethod</code></a> is used to compute the median. However, this default may be overloaded for specific manifolds.</p><pre><code class="language-none">median(M::Manifold, x::AbstractVector, [w::AbstractWeights], method::AbstractMethod; kwargs...)</code></pre><p>Compute the median using the specified <code>method</code>.</p><pre><code class="language-none">median(
    M::Manifold,
    x::AbstractVector,
    w::AbstractWeights,
    method::CyclicProximalPointMethod;
    x0=x[1],
    stop_iter=1000000,
    kwargs...
)</code></pre><p>Compute the median using <a href="index.html#Manifolds.CyclicProximalPointMethod"><code>CyclicProximalPointMethod</code></a>.</p><p>Optionally, provide <code>x0</code>, the starting point (by default set to the first data point). Set <code>x0</code> to <code>nothing</code> to use the intitial value of <code>y</code> as the starting point. <code>stop_iter</code> denotes the maximal number of iterations to perform and the <code>kwargs...</code> are passed to <a href="interface.html#Base.isapprox-Tuple{Manifold,Any,Any,Any}"><code>isapprox</code></a> to stop, when the minimal change between two iterates is small. For more stopping criteria check the <a href="https://manoptjl.org"><code>Manopt.jl</code></a> package and use a solver therefrom.</p><p>The algorithm is further described in Algorithm 4.3 and 4.4 in <a href="#Bačák2014">[Bačák, 2014]</a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.std" href="#Statistics.std"><code>Statistics.std</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">std(M, x, m=nothing; corrected=true, kwargs...)</code></pre><p>compute the variance of a <code>Vector</code> <code>x</code> of <code>n</code> data points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, i.e.</p><div>\[\sqrt{\frac{1}{c} \sum_{i=1}^n d_{\mathcal M}^2 (x_i,m)},\]</div><p>where <code>c</code> is a correction term, see <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.var">Statistics.var</a>. and <code>m</code> is the provideed mean of <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.std" href="#Statistics.std"><code>Statistics.std</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">std(M, x, w::AbstractWeights, m=nothing; corrected=false, kwargs...)</code></pre><p>compute the (weighted) standard deviation of a <code>Vector</code> <code>x</code> of <code>n</code> data points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, i.e.</p><div>\[\sqrt{\frac{1}{c} \sum_{i=1}^n w_i d_{\mathcal M}^2 (x_i,m)},\]</div><p>where <code>c</code> is a correction term, see <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.var">Statistics.var</a>. The (weighted) mean of <code>x</code> can be specified as <code>m</code>, and the corrected variance can be activated by setting <code>corrected=true</code>. All further <code>kwargs...</code> are passed to the computation of the mean (if that is not provided).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.var" href="#Statistics.var"><code>Statistics.var</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">var(M, x, m=nothing; corrected=true, kwargs...)</code></pre><p>compute the variance of a <code>Vector</code> <code>x</code> of <code>n</code> data points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, i.e.</p><div>\[\frac{1}{c} \sum_{i=1}^n d_{\mathcal M}^2 (x_i,m),\]</div><p>where <code>c</code> is a correction term, see <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.var">Statistics.var</a>. and <code>m</code> is the provideed mean of <code>x</code>. The uncorrected variance can be activated by setting <code>corrected=false</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Statistics.var" href="#Statistics.var"><code>Statistics.var</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">var(M, x, w::AbstractWeights, m=nothing; corrected=false, kwargs...)</code></pre><p>compute the (weighted) variance of a <code>Vector</code> <code>x</code> of <code>n</code> data points on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, i.e.</p><div>\[\frac{1}{c} \sum_{i=1}^n w_i d_{\mathcal M}^2 (x_i,m),\]</div><p>where <code>c</code> is a correction term, see <a href="https://juliastats.org/StatsBase.jl/stable/scalarstats/#Statistics.var">Statistics.var</a>. The (weighted) mean of <code>x</code> can be specified as <code>m</code>, and the corrected variance can be activated by setting <code>corrected=true</code>. All further <code>kwargs...</code> are passed to the computation of the mean (if that is not provided).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.mean_and_std-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}" href="#StatsBase.mean_and_std-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}"><code>StatsBase.mean_and_std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_and_std(M, x, w; corrected = false, kwargs...) -&gt; (mean, std)
mean_and_std(M, x; corrected = true, kwargs...) -&gt; (mean, std)</code></pre><p>compute the <a href="manifolds/rotations.html#Statistics.mean-Tuple{Manifolds.Rotations,Vararg{Any,N} where N}"><code>mean</code></a> <code>m</code> and the standard deviation <a href="statistics.html#Statistics.std"><code>std</code></a> <code>s</code> simultaneously.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}" href="#StatsBase.mean_and_var-Tuple{Manifold,AbstractArray{T,1} where T,StatsBase.AbstractWeights}"><code>StatsBase.mean_and_var</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">mean_and_var(M, x, w; corrected = false, kwargs...) -&gt; (mean, var)
mean_and_var(M, x; corrected = true, kwargs...) -&gt; (mean, var)</code></pre><p>compute the <a href="manifolds/rotations.html#Statistics.mean-Tuple{Manifolds.Rotations,Vararg{Any,N} where N}"><code>mean</code></a> <code>m</code> and the <a href="statistics.html#Statistics.var"><code>var</code></a>iance <code>v</code> simultaneously.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Manifolds.GeodesicInterpolationMethod" href="#Manifolds.GeodesicInterpolationMethod"><code>Manifolds.GeodesicInterpolationMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GeodesicInterpolationMethod &lt;: AbstractMethod</code></pre><p>Repeated weighted geodesic interpolation method for estimating the Riemannian center of mass.</p><p>The algorithm proceeds with the following simple online update:</p><div>\[\begin{aligned}
\mu_1 &amp;= x_1\\
t_k &amp;= \frac{w_k}{\sum_{i=1}^k w_i}\\
\mu_{k} &amp;= \gamma_{\mu_{k-1}}(x_k; t_k),
\end{aligned}\]</div><p>where <span>$x_k$</span> are points, <span>$w_k$</span> are weights, <span>$\mu_k$</span> is the <span>$k$</span>th estimate of the mean, and <span>$\gamma_x(y; t)$</span> is the point at time <span>$t$</span> along the <a href="interface.html#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any,AbstractArray{T,1} where T}"><code>shortest_geodesic</code></a> between points <span>$x,y \in \mathcal M$</span>. The algorithm terminates when all <span>$x_k$</span> have been considered. In the <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a> case, this exactly computes the weighted mean.</p><p>The algorithm has been shown to converge asymptotically with the sample size for the following manifolds equipped with their default metrics when all sampled points are in an open geodesic ball about the mean with corresponding radius:</p><ul><li><a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a>: <span>$\infty$</span></li><li><a href="manifolds/symmetricpositivedefinite.html#Manifolds.SymmetricPositiveDefinite"><code>SymmetricPositiveDefinite</code></a> <a href="#Ho2013">[Ho et al, 2013]</a>: <span>$\infty$</span></li><li><a href="manifolds/sphere.html#Manifolds.Sphere"><code>Sphere</code></a> <a href="#Salehian2015">[Salehian et al, 2015]</a>: <span>$\frac{\pi}{2}$</span></li><li><code>Grassmannian</code> <a href="#ChakrabortyVemuri2015">[Chakraborty and Vemuri, 2015]</a>: <span>$\frac{\pi}{4}$</span></li><li><code>Stiefel</code>/<a href="manifolds/rotations.html#Manifolds.Rotations"><code>Rotations</code></a> <a href="#ChakrabortyVemuri2019">[Chakraborty and Vemuri, 2019]</a>: <span>$\frac{\pi}{2 \sqrt 2}$</span></li></ul></div></section></article><h2 id="Literature-1"><a class="docs-heading-anchor" href="#Literature-1">Literature</a><a class="docs-heading-anchor-permalink" href="#Literature-1" title="Permalink"></a></h2><ul>
  <li id="Afsari2013">[<a>Afsari et al, 2013</a>]
     Afsari, B; Tron, R; Vidal, R: "On the Convergence of Gradient
     Descent for Finding the Riemannian Center of Mass,"
     <i>SIAM Journal on Control and Optimization</i> (2013), 51(3), pp. 2230–2260.
     doi: <a href="https://doi.org/10.1137/12086282X">10.1137/12086282X</a>,
     arxiv: <a href="https://arxiv.org/abs/1201.0925">1201.0925</a>.
  </li>
  <li id="Bačák2014">[<a>Bačák, 2014</a>]
    Bačák, M: "Computing Medians and Means in Hadamard Spaces,"
    <i>SIAM Journal on Optimization</i> (2014), 24(3), pp. 1542–1566,
    doi: <a href="https://doi.org/10.1137/140953393">10.1137/140953393</a>,
    arxiv: <a href="https://arxiv.org/abs/1210.2145">1210.2145</a>.
  </li>
  <li id="Ho2013">[<a>Ho et al, 2013</a>]
    Ho J; Cheng G; Salehian H; Vemuri B C: "Recursive Karcher expectation
    estimators and geometric law of large numbers,"
    <i>Proceedings of the 16th International Conference on Artificial
    Intelligence and Statistics</i> (2013), pp. 325–332,
    <a href="http://proceedings.mlr.press/v31/ho13a.pdf">pdf</a>.
  </li>
  <li id="Salehian2015">[<a>Salehian et al, 2015</a>]
    Salehian H; Chakraborty R; Ofori E; Vaillancourt D: "An efficient
    recursive estimator of the Fréchet mean on a hypersphere with applications
    to Medical Image Analysis,"
    <i>Mathematical Foundations of Computational Anatomy</i> (2015),
    <a href="https://www-sop.inria.fr/asclepios/events/MFCA15/Papers/MFCA15_4_2.pdf">pdf</a>.
  </li>
  <li id="ChakrabortyVemuri2015">[<a>Chakraborty and Vemuri, 2015</a>]
    Chakraborty R; Vemuri B C: "Recursive Fréchet Mean Computation on the
    Grassmannian and Its Applications to Computer Vision,"
    <i>Proceedings of the IEEE International Conference on Computer Vision (ICCV)</i>
    (2015), pp. 4229-4237.
    doi: <a href="https://doi.org/10.1109/ICCV.2015.481">10.1109/ICCV.2015.481</a>,
    <a href="http://openaccess.thecvf.com/content_iccv_2015/html/Chakraborty_Recursive_Frechet_Mean_ICCV_2015_paper.html">link</a>.
  </li>
  <li id="ChakrabortyVemuri2019">[<a>Chakraborty and Vemuri, 2019</a>]
    Chakraborty R; Vemuri B C: "Statistics on the Stiefel manifold:
    Theory and Applications,"
    <i>The Annals of Statistics</i> (2019), 47(1), pp. 415-438.
    doi: <a href="https://doi.org/10.1214/18-AOS1692">10.1214/18-AOS1692</a>,
    arxiv: <a href="https://arxiv.org/abs/1708.00045">1708.00045</a>.
  </li>
</ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="manifolds/metric.html">« Metric manifold</a><a class="docs-footer-nextpage" href="distributions.html">Distributions »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 16 December 2019 22:59">Monday 16 December 2019</span>. Using Julia version 1.2.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
