<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ManifoldsBase.jl · Manifolds</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Manifolds</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="interface.html">ManifoldsBase.jl</a></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/circle.html">Circle</a></li><li><a class="tocitem" href="manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="manifolds/fixedrankmatrices.html">Fixed Rank Matrices</a></li><li><a class="tocitem" href="manifolds/choleskyspace.html">Cholesky Space</a></li><li><a class="tocitem" href="manifolds/grassmann.html">Grassmannian</a></li><li><a class="tocitem" href="manifolds/hyperbolic.html">Hyperbolic Space</a></li><li><a class="tocitem" href="manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="manifolds/stiefel.html">Stiefel</a></li><li><a class="tocitem" href="manifolds/symmetric.html">Symmetric Matrices</a></li><li><a class="tocitem" href="manifolds/symmetricpositivedefinite.html">Symmetric Positive Definite</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/array.html">Array manifold</a></li><li><a class="tocitem" href="manifolds/metric.html">Metric manifold</a></li><li><a class="tocitem" href="manifolds/group.html">Group manifold</a></li></ul></li></ul></li><li><a class="tocitem" href="statistics.html">Statistics</a></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/public.html">Public</a></li><li><a class="tocitem" href="lib/internals.html">Internals</a></li><li><a class="tocitem" href="lib/autodiff.html">Automatic Differentiation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="interface.html">ManifoldsBase.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="interface.html">ManifoldsBase.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaNLSolvers/Manifolds.jl/blob/master/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ManifoldsBase.jl-–-An-Interface-for-Manifolds-1"><a class="docs-heading-anchor" href="#ManifoldsBase.jl-–-An-Interface-for-Manifolds-1">ManifoldsBase.jl – An Interface for Manifolds</a><a class="docs-heading-anchor-permalink" href="#ManifoldsBase.jl-–-An-Interface-for-Manifolds-1" title="Permalink"></a></h1><p>The interface for a manifold is provided in the lightweight package <a href="https://github.com/JuliaNLSolvers/ManifoldsBase.jl">`ManifoldsBase.jl</a> separate from the collection of manifolds in here. You can easily implement your algorithms and even first own manifolds just using the interface.</p><p>The following functions are currently available from the interface. If a manifold that you implement for your own package fits this interface, we happily look forward to a <a href="https://github.com/JuliaNLSolvers/Manifolds.jl/compare">Pull Request</a> to add it here.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CoTVector" href="#ManifoldsBase.CoTVector"><code>ManifoldsBase.CoTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoTVector</code></pre><p>Type for a cotangent vector of a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.MPoint" href="#ManifoldsBase.MPoint"><code>ManifoldsBase.MPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPoint</code></pre><p>Type for a point on a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of points on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.Manifold" href="#ManifoldsBase.Manifold"><code>ManifoldsBase.Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Manifold</code></pre><p>A manifold type. The <code>Manifold</code> is used to dispatch to different functions on a manifold, usually as the first argument of the function. Examples are the <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential and <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic maps as well as more general functions that are built on them like the <a href="interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>geodesic</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ParallelTransport" href="#ManifoldsBase.ParallelTransport"><code>ManifoldsBase.ParallelTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParallelTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use parallel transport as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionTransport" href="#ManifoldsBase.ProjectionTransport"><code>ManifoldsBase.ProjectionTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectionTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use projection onto tangent space as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a>. See <a href="interface.html#ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}"><code>project_tangent</code></a> for details.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TVector" href="#ManifoldsBase.TVector"><code>ManifoldsBase.TVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TVector</code></pre><p>Type for a tangent vector of a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{Manifold,Any,Any}" href="#Base.exp-Tuple{Manifold,Any,Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(M::Manifold, x, v, t::Real = 1)
exp(M::Manifold, x, v, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Exponential map of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code>. <code>t</code> may be a scalar or elements of vector <code>T</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Manifold,Any,Any,Any}" href="#Base.isapprox-Tuple{Manifold,Any,Any,Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isapprox(M::Manifold, x, v, w; kwargs...)</code></pre><p>Check if vectors <code>v</code> and <code>w</code> tangent at <code>x</code> from manifold <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Manifold,Any,Any}" href="#Base.isapprox-Tuple{Manifold,Any,Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isapprox(M::Manifold, x, y; kwargs...)</code></pre><p>Check if points <code>x</code> and <code>y</code> from manifold <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{Manifold,Any,Any}" href="#Base.log-Tuple{Manifold,Any,Any}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log(M::Manifold, x, y)</code></pre><p>Logarithmic map of point <code>y</code> at base point <code>x</code> on Manifold <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Manifold,Any,Any}" href="#LinearAlgebra.norm-Tuple{Manifold,Any,Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(M::Manifold, x, v)</code></pre><p>Norm of tangent vector <code>v</code> at point <code>x</code> from manifold <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold-Tuple{Manifold}" href="#ManifoldsBase.base_manifold-Tuple{Manifold}"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">base_manifold(M::Manifold)</code></pre><p>Return the internally stored manifold for decorated manifolds and the base manifold for vector bundles or power manifolds.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}" href="#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>ManifoldsBase.check_manifold_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_manifold_point(M::Manifold, x; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Return <code>nothing</code> when <code>x</code> is a point on manifold <code>M</code>. Otherwise, return a string with a description why the point does not belong to manifold <code>M</code>.</p><p>By default, <code>check_manifold_point</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the <a href="interface.html#ManifoldsBase.MPoint"><code>MPoint</code></a> type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.check_tangent_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_tangent_vector(M::Manifold, x, v; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Check whether <code>v</code> is a valid tangent vector in the tangent plane of <code>x</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. An implementation should first call <a href="interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point(M, x; kwargs...)</code></a> and then validate <code>v</code>. If it is not a tangent vector, an error string should be returned.</p><p>By default, <code>check_tangent_vector</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the <a href="interface.html#ManifoldsBase.TVector"><code>TVector</code></a> type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(M::Manifold, x, y)</code></pre><p>Shortest distance between the points <code>x</code> and <code>y</code> on manifold <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.exp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp!(M::Manifold, y, x, v, t::Real = 1)</code></pre><p>Exponential map of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code>. Result is saved to <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geodesic(M::Manifold, x, v) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>x</code> and velocity <code>v</code>. The geodesic is the curve of constant velocity that is locally distance-minimizing. This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p><pre><code class="language-none">geodesic(M::Manifold, x, v, t::Real)
geodesic(M::Manifold, x, v, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the geodesic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{Manifold}" href="#ManifoldsBase.injectivity_radius-Tuple{Manifold}"><code>ManifoldsBase.injectivity_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">injectivity_radius(M::Manifold, x)</code></pre><p>Distance <span>$d$</span> such that <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp(M, x, v)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has a left inverse).</p><pre><code class="language-none">injectivity_radius(M::Manifold)</code></pre><p>Infimum of the injectivity radius of all manifold points.</p><pre><code class="language-none">injectivity_radius(M::Manifold[, x], method::AbstractRetractionMethod)</code></pre><p>Distance <span>$d$</span> such that <a href="interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>retract(M, x, v, method)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has a left inverse) for point <span>$x$</span> if provided or all manifold points otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner(M::Manifold, x, v, w)</code></pre><p>Inner product of tangent vectors <code>v</code> and <code>w</code> at point <code>x</code> from manifold <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.inverse_retract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_retract!(M::Manifold, v, x, y[, method::AbstractInverseRetractionMethod])</code></pre><p>Inverse retraction (cheaper, approximate version of <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map) of points <code>x</code> and <code>y</code>. Result is saved to <code>v</code>.</p><p>Inverse retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.LogarithmicInverseRetraction"><code>LogarithmicInverseRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.inverse_retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_retract(M::Manifold, x, y)
inverse_retract(M::Manifold, x, y, method::AbstractInverseRetractionMethod</code></pre><p>Inverse retraction (cheaper, approximate version of <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map) of points <code>x</code> and <code>y</code> from manifold <code>M</code>.</p><p>Inverse retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.LogarithmicInverseRetraction"><code>LogarithmicInverseRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_decorator_manifold-Tuple{Manifold}" href="#ManifoldsBase.is_decorator_manifold-Tuple{Manifold}"><code>ManifoldsBase.is_decorator_manifold</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_decorator_manifold(M::Manifold)</code></pre><p>Indicate whether a manifold is a decorator manifold, i.e. whether it encapsulates a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> with additional features and stores internally the original manifold instance. An example is the <a href="manifolds/array.html#ManifoldsBase.ArrayManifold"><code>ArrayManifold</code></a>.</p><p>Certain functions are just calling themselves on the internal manifold and hence do not need to be reimplemented for decorators again, for example <a href="interface.html#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>manifold_dimension</code></a> and especially <a href="interface.html#ManifoldsBase.base_manifold-Tuple{Manifold}"><code>base_manifold</code></a>.</p><p>It is assumed that the undecorated (base) manifold is stored in <code>M.manifold</code>. Alternatively, overload <a href="interface.html#ManifoldsBase.base_manifold-Tuple{Manifold}"><code>base_manifold</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_manifold_point" href="#ManifoldsBase.is_manifold_point"><code>ManifoldsBase.is_manifold_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_manifold_point(M::Manifold, x, throw_error = false; kwargs...)</code></pre><p>Return whether <code>x</code> is a valid point on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point(M, x; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_tangent_vector" href="#ManifoldsBase.is_tangent_vector"><code>ManifoldsBase.is_tangent_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_tangent_vector(M::Manifold, x, v, throw_error = false; kwargs...)</code></pre><p>Return whether <code>v</code> is a valid tangent vector at point <code>x</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Returns either <code>true</code> or <code>false</code>.</p><p>The default is to return <code>true</code>, i.e. if no checks are implemented, the assumption is to be optimistic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.log!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log!(M::Manifold, v, x, y)</code></pre><p>Logarithmic map of point <code>y</code> at base point <code>x</code> on Manifold <code>M</code>. Result is saved to <code>v</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{Manifold}" href="#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>ManifoldsBase.manifold_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">manifold_dimension(M::Manifold)</code></pre><p>The dimension <span>$n$</span> of real space <span>$\mathbb R^n$</span> to which the neighborhood of each point of the manifold is homeomorphic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project_point!-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.project_point!-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.project_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_point!(M::Manifold, y, x)</code></pre><p>Project point <code>x</code> from the ambient space onto the manifold <code>M</code>. The point <code>y</code> is overwritten by the projection. The function works only for selected embedded manifolds and is <em>not</em> required to return the closest point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project_point-Tuple{Manifold,Any}" href="#ManifoldsBase.project_point-Tuple{Manifold,Any}"><code>ManifoldsBase.project_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_point(M::Manifold, x)</code></pre><p>Project point from the ambient space onto the manifold <code>M</code>. The point <code>x</code> is not modified. The function works only for selected embedded manifolds and is <em>not</em> required to return the closest point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project_tangent!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.project_tangent!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.project_tangent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_tangent!(M::Manifold, w, x, v)</code></pre><p>Project ambient space representation of a vector <code>v</code> to a tangent vector at point <code>x</code> from the manifold <code>M</code>. The result is saved in vector <code>w</code>.</p><p>The function works only for selected embedded manifolds and is <em>not</em> required to return the closest vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.project_tangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_tangent(M::Manifold, x, v)</code></pre><p>Project ambient space representation of a vector <code>v</code> to a tangent vector at point <code>x</code> from the manifold <code>M</code>.</p><p>The function works only for selected embedded manifolds and is <em>not</em> required to return the closest vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.representation_size-Tuple{Manifold}" href="#ManifoldsBase.representation_size-Tuple{Manifold}"><code>ManifoldsBase.representation_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representation_size(M::Manifold)</code></pre><p>The size of an array representing a point on manifold <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.retract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">retract!(M::Manifold, y, x, v[, t::Real=1])
retract!(M::Manifold, y, x, v[, t::Real=1], method::AbstractRetractionMethod)</code></pre><p>Retraction (cheaper, approximate version of <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential map) of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code>. Result is saved to <code>y</code>.</p><p>Retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">retract(M::Manifold, x, v[, t::Real=1])
retract(M::Manifold, x, v[, t::Real=1], method::AbstractRetractionMethod)</code></pre><p>Retraction (cheaper, approximate version of <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential map) of tangent vector <code>t*v</code> at point <code>x</code> from manifold <code>M</code>.</p><p>Retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shortest_geodesic(M::Manifold, x, y) -&gt; Function</code></pre><p>Get a <a href="interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>geodesic</code></a> <span>$\gamma_x(t)$</span> whose length is the shortest path between the points <span>$x$</span> and <span>$y$</span>, where <span>$\gamma_x(0)=x$</span> and <span>$\gamma_x(1)=y$</span>. When there are multiple shortest geodesics, there is no guarantee which will be returned.</p><p>This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p><pre><code class="language-none">shortest_geodesic(M::Manifold, x, y, t::Real)
shortest_geodesic(M::Manifold, x, y, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <span>$t$</span> or points at times <span>$t$</span> in <span>$T$</span> along the shortest geodesic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_along!(M::Manifold, vto, x, v, c[, method::AbstractVectorTransportMethod])</code></pre><p>Transport a vector <code>v</code> at point <code>x</code> along the curve <code>c</code> such that <code>c(0)</code> is equal to <code>x</code> to point <code>c(1)</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>. The result is saved to <code>vto</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_along</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_along(M::Manifold, x, v, c[, method::AbstractVectorTransportMethod])</code></pre><p>Transport a vector <code>v</code> at point <code>x</code> along the curve <code>c</code> such that <code>c(0)</code> is equal to <code>x</code> to point <code>c(1)</code>. The default <code>method</code> used is <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_direction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_direction!(M::Manifold, vto, x, v, vdir[, method::AbstractVectorTransportMethod])</code></pre><p>Transport a vector <code>v</code> at point <code>x</code> in the direction indicated by the tangent vector <code>vdir</code> at point <code>x</code>. The result is saved to <code>vto</code>. By default, <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> and <a href="interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_direction(M::Manifold, x, v, vdir[, method::AbstractVectorTransportMethod])</code></pre><p>Transport a vector <code>v</code> at point <code>x</code> in the direction indicated by the tangent vector <code>vdir</code> at point <code>x</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}" href="#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, vto, x, v, y, method::ProjectionTransport)</code></pre><p>Transport a vector <code>v</code> in the tangent space at <code>x</code> on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> by interpreting it as an element of the embedding and then projecting it onto the tangent space at <code>y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, vto, x, v, y[, method::AbstractVectorTransportMethod])</code></pre><p>Vector transport of vector <code>v</code> at point <code>x</code> to point <code>y</code>. The result is saved to <code>vto</code>. By default, the <code>method</code> is <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to(M::Manifold, x, v, y[, method::AbstractVectorTransportMethod])</code></pre><p>Transport a vector <code>v</code> at point <code>x</code> to point <code>y</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_tangent_vector!-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.zero_tangent_vector!-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.zero_tangent_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_tangent_vector!(M::Manifold, v, x)</code></pre><p>Save to <code>v</code> a vector such that retracting <code>v</code> to manifold <code>M</code> at <code>x</code> produces <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_tangent_vector-Tuple{Manifold,Any}" href="#ManifoldsBase.zero_tangent_vector-Tuple{Manifold,Any}"><code>ManifoldsBase.zero_tangent_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_tangent_vector(M::Manifold, x)</code></pre><p>Vector <code>v</code> such that retracting <code>v</code> to manifold <code>M</code> at <code>x</code> produces <code>x</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractEstimationMethod" href="#ManifoldsBase.AbstractEstimationMethod"><code>ManifoldsBase.AbstractEstimationMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEstimationMethod</code></pre><p>Abstract type for defining statistical estimation methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractInverseRetractionMethod" href="#ManifoldsBase.AbstractInverseRetractionMethod"><code>ManifoldsBase.AbstractInverseRetractionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractInverseRetractionMethod</code></pre><p>Abstract type for methods for inverting a retraction (see <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>inverse_retract</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractRetractionMethod" href="#ManifoldsBase.AbstractRetractionMethod"><code>ManifoldsBase.AbstractRetractionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractRetractionMethod</code></pre><p>Abstract type for methods for <a href="interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>retract</code></a>ing a tangent vector to a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractVectorTransportMethod" href="#ManifoldsBase.AbstractVectorTransportMethod"><code>ManifoldsBase.AbstractVectorTransportMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractVectorTransportMethod</code></pre><p>Abstract type for methods for transporting vectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ExponentialRetraction" href="#ManifoldsBase.ExponentialRetraction"><code>ManifoldsBase.ExponentialRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExponentialRetraction</code></pre><p>Retraction using the exponential map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.LogarithmicInverseRetraction" href="#ManifoldsBase.LogarithmicInverseRetraction"><code>ManifoldsBase.LogarithmicInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogarithmicInverseRetraction</code></pre><p>Inverse retraction using the <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.OutOfInjectivityRadiusError" href="#ManifoldsBase.OutOfInjectivityRadiusError"><code>ManifoldsBase.OutOfInjectivityRadiusError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OutOfInjectivityRadiusError</code></pre><p>An error thrown when a function (for example <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map or <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>inverse_retract</code></a>) is given arguments outside of its <a href="interface.html#ManifoldsBase.injectivity_radius-Tuple{Manifold}"><code>injectivity_radius</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{Manifold,Any,Any,Any}" href="#Base.angle-Tuple{Manifold,Any,Any,Any}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle(M::Manifold, x, v, w)</code></pre><p>Angle between tangent vectors <code>v</code> and <code>w</code> at point <code>x</code> from manifold <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.similar_result-Tuple{Manifold,Any,Vararg{Any,N} where N}" href="#ManifoldsBase.similar_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>ManifoldsBase.similar_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">similar_result(M::Manifold, f, x...)</code></pre><p>Allocate an array for the result of function <code>f</code> on manifold <code>M</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p><p>Usefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.similar_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N" href="#ManifoldsBase.similar_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N"><code>ManifoldsBase.similar_result_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">similar_result_type(M::Manifold, f, args::NTuple{N,Any}) where N</code></pre><p>Return type of element of the array that will represent the result of function <code>f</code> for manifold <code>M</code> on given arguments <code>args</code> (passed as a tuple).</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="manifolds/circle.html">Circle »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 4 January 2020 04:58">Saturday 4 January 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
