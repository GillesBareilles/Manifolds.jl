<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>ManifoldsBase.jl · Manifolds.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="index.html"><img class="docs-light-only" src="assets/logo.png" alt="Manifolds.jl logo"/><img class="docs-dark-only" src="assets/logo-dark.png" alt="Manifolds.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">Manifolds.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="index.html">Home</a></li><li class="is-active"><a class="tocitem" href="interface.html">ManifoldsBase.jl</a><ul class="internal"><li><a class="tocitem" href="#Types-and-functions-1"><span>Types and functions</span></a></li><li><a class="tocitem" href="#DefaultManifold-1"><span><code>DefaultManifold</code></span></a></li><li><a class="tocitem" href="#Allocation-1"><span>Allocation</span></a></li></ul></li><li><span class="tocitem">Manifolds</span><ul><li><input class="collapse-toggle" id="menuitem-3-1" type="checkbox"/><label class="tocitem" for="menuitem-3-1"><span class="docs-label">Basic manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/choleskyspace.html">Cholesky space</a></li><li><a class="tocitem" href="manifolds/circle.html">Circle</a></li><li><a class="tocitem" href="manifolds/euclidean.html">Euclidean</a></li><li><a class="tocitem" href="manifolds/fixedrankmatrices.html">Fixed-rank matrices</a></li><li><a class="tocitem" href="manifolds/grassmann.html">Grassmannian manifold</a></li><li><a class="tocitem" href="manifolds/hyperbolic.html">Hyperbolic space</a></li><li><a class="tocitem" href="manifolds/lorentz.html">Lorentzian manifold</a></li><li><a class="tocitem" href="manifolds/oblique.html">Oblique manifold</a></li><li><a class="tocitem" href="manifolds/rotations.html">Rotations</a></li><li><a class="tocitem" href="manifolds/skewsymmetric.html">Skew-symmetric matrices</a></li><li><a class="tocitem" href="manifolds/sphere.html">Sphere</a></li><li><a class="tocitem" href="manifolds/stiefel.html">Stiefel</a></li><li><a class="tocitem" href="manifolds/symmetric.html">Symmetric matrices</a></li><li><a class="tocitem" href="manifolds/symmetricpositivedefinite.html">Symmetric positive definite</a></li><li><a class="tocitem" href="manifolds/torus.html">Torus</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Combined manifolds</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/graph.html">Graph manifold</a></li><li><a class="tocitem" href="manifolds/power.html">Power manifold</a></li><li><a class="tocitem" href="manifolds/product.html">Product manifold</a></li><li><a class="tocitem" href="manifolds/vector_bundle.html">Vector bundle</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Manifold decorators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="manifolds/decorator.html">Decorator manifold</a></li><li><a class="tocitem" href="manifolds/array.html">Array manifold</a></li><li><a class="tocitem" href="manifolds/embedded.html">Embedded manifold</a></li><li><a class="tocitem" href="manifolds/metric.html">Metric manifold</a></li><li><a class="tocitem" href="manifolds/group.html">Group manifold</a></li></ul></li></ul></li><li><a class="tocitem" href="statistics.html">Statistics</a></li><li><a class="tocitem" href="distributions.html">Distributions</a></li><li><a class="tocitem" href="orthonormal_bases.html">Orthonormal bases</a></li><li><a class="tocitem" href="notation.html">Notation</a></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="lib/numbers.html">Number systems</a></li><li><a class="tocitem" href="lib/public.html">Public</a></li><li><a class="tocitem" href="lib/internals.html">Internals</a></li><li><a class="tocitem" href="lib/autodiff.html">Automatic differentiation</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="interface.html">ManifoldsBase.jl</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="interface.html">ManifoldsBase.jl</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaNLSolvers/Manifolds.jl/blob/master/docs/src/interface.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="ManifoldsBase.jl-–-an-interface-for-manifolds-1"><a class="docs-heading-anchor" href="#ManifoldsBase.jl-–-an-interface-for-manifolds-1"><code>ManifoldsBase.jl</code> – an interface for manifolds</a><a class="docs-heading-anchor-permalink" href="#ManifoldsBase.jl-–-an-interface-for-manifolds-1" title="Permalink"></a></h1><p>The interface for a manifold is provided in the lightweight package <a href="https://github.com/JuliaNLSolvers/ManifoldsBase.jl">ManifoldsBase.jl</a> separate from the collection of manifolds in here. You can easily implement your algorithms and even your own manifolds just using the interface.</p><ul><li><a href="interface.html#ManifoldsBase.jl-–-an-interface-for-manifolds-1"><code>ManifoldsBase.jl</code> – an interface for manifolds</a></li><ul><li><a href="interface.html#Types-and-functions-1">Types and functions</a></li><li><a href="interface.html#DefaultManifold-1"><code>DefaultManifold</code></a></li><li><a href="interface.html#Allocation-1">Allocation</a></li></ul></ul><p>Additionally the <a href="manifolds/decorator.html#ManifoldsBase.AbstractDecoratorManifold"><code>AbstractDecoratorManifold</code></a> is provided as well as the <a href="manifolds/array.html#ManifoldsBase.ArrayManifold"><code>ArrayManifold</code></a> as a specific example of such a decorator.</p><h2 id="Types-and-functions-1"><a class="docs-heading-anchor" href="#Types-and-functions-1">Types and functions</a><a class="docs-heading-anchor-permalink" href="#Types-and-functions-1" title="Permalink"></a></h2><p>The following functions are currently available from the interface. If a manifold that you implement for your own package fits this interface, we happily look forward to a <a href="https://github.com/JuliaNLSolvers/Manifolds.jl/compare">Pull Request</a> to add it here.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractInverseRetractionMethod" href="#ManifoldsBase.AbstractInverseRetractionMethod"><code>ManifoldsBase.AbstractInverseRetractionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractInverseRetractionMethod</code></pre><p>Abstract type for methods for inverting a retraction (see <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>inverse_retract</code></a>).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractRetractionMethod" href="#ManifoldsBase.AbstractRetractionMethod"><code>ManifoldsBase.AbstractRetractionMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractRetractionMethod</code></pre><p>Abstract type for methods for <a href="interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>retract</code></a>ing a tangent vector to a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.CoTVector" href="#ManifoldsBase.CoTVector"><code>ManifoldsBase.CoTVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">CoTVector</code></pre><p>Type for a cotangent vector of a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of cotangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ExponentialRetraction" href="#ManifoldsBase.ExponentialRetraction"><code>ManifoldsBase.ExponentialRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ExponentialRetraction</code></pre><p>Retraction using the exponential map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.LogarithmicInverseRetraction" href="#ManifoldsBase.LogarithmicInverseRetraction"><code>ManifoldsBase.LogarithmicInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">LogarithmicInverseRetraction</code></pre><p>Inverse retraction using the <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.MPoint" href="#ManifoldsBase.MPoint"><code>ManifoldsBase.MPoint</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MPoint</code></pre><p>Type for a point on a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of points on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.Manifold" href="#ManifoldsBase.Manifold"><code>ManifoldsBase.Manifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Manifold</code></pre><p>A manifold type. The <code>Manifold</code> is used to dispatch to different functions on a manifold, usually as the first argument of the function. Examples are the <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential and <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic maps as well as more general functions that are built on them like the <a href="interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>geodesic</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ParallelTransport" href="#ManifoldsBase.ParallelTransport"><code>ManifoldsBase.ParallelTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ParallelTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use parallel transport as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PolarInverseRetraction" href="#ManifoldsBase.PolarInverseRetraction"><code>ManifoldsBase.PolarInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PolarInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a singular value decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.PolarRetraction" href="#ManifoldsBase.PolarRetraction"><code>ManifoldsBase.PolarRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PolarRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on singular value decompositions of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionInverseRetraction" href="#ManifoldsBase.ProjectionInverseRetraction"><code>ManifoldsBase.ProjectionInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectionInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a projection (or its inversion).</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionRetraction" href="#ManifoldsBase.ProjectionRetraction"><code>ManifoldsBase.ProjectionRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectionRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on projection and usually addition in the embedding.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.ProjectionTransport" href="#ManifoldsBase.ProjectionTransport"><code>ManifoldsBase.ProjectionTransport</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">ProjectionTransport &lt;: AbstractVectorTransportMethod</code></pre><p>Specify to use projection onto tangent space as vector transport method within <a href="interface.html#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_to</code></a>, <a href="interface.html#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_direction</code></a>, or <a href="interface.html#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>vector_transport_along</code></a>. See <a href="interface.html#ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}"><code>project_tangent</code></a> for details.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.QRInverseRetraction" href="#ManifoldsBase.QRInverseRetraction"><code>ManifoldsBase.QRInverseRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QRInverseRetraction &lt;: AbstractInverseRetractionMethod</code></pre><p>Inverse retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.QRRetraction" href="#ManifoldsBase.QRRetraction"><code>ManifoldsBase.QRRetraction</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">QRRetraction &lt;: AbstractRetractionMethod</code></pre><p>Retractions that are based on a QR decomposition of the matrix / matrices for point and tangent vector on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a></p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.TVector" href="#ManifoldsBase.TVector"><code>ManifoldsBase.TVector</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">TVector</code></pre><p>Type for a tangent vector of a manifold. While a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> does not necessarily require this type, for example when it is implemented for <code>Vector</code>s or <code>Matrix</code> type elements, this type can be used for more complicated representations, semantic verification, or even dispatch for different representations of tangent vectors and their types on a manifold.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.exp-Tuple{Manifold,Any,Any}" href="#Base.exp-Tuple{Manifold,Any,Any}"><code>Base.exp</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp(M::Manifold, p, X)
exp(M::Manifold, p, X, t::Real = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from manifold the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Manifold,Any,Any,Any}" href="#Base.isapprox-Tuple{Manifold,Any,Any,Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isapprox(M::Manifold, p, X, Y; kwargs...)</code></pre><p>Check if vectors <code>X</code> and <code>Y</code> tangent at <code>p</code> from <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.isapprox-Tuple{Manifold,Any,Any}" href="#Base.isapprox-Tuple{Manifold,Any,Any}"><code>Base.isapprox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">isapprox(M::Manifold, p, q; kwargs...)</code></pre><p>Check if points <code>p</code> and <code>q</code> from <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> are approximately equal.</p><p>Keyword arguments can be used to specify tolerances.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.log-Tuple{Manifold,Any,Any}" href="#Base.log-Tuple{Manifold,Any,Any}"><code>Base.log</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log(M::Manifold, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.norm-Tuple{Manifold,Any,Any}" href="#LinearAlgebra.norm-Tuple{Manifold,Any,Any}"><code>LinearAlgebra.norm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">norm(M::Manifold, p, X)</code></pre><p>Compute the norm of tangent vector <code>X</code> at point <code>p</code> from a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. By default this is computed using <a href="interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>inner</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}" href="#ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}"><code>ManifoldsBase.allocate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allocate(a)
allocate(a, dims::Int...)
allocate(a, dims::Tuple)
allocate(a, T::Type)
allocate(a, T::Type, dims::Int...)
allocate(a, T::Type, dims::Tuple)</code></pre><p>Allocate an object similar to <code>a</code>. It is similar to function <code>similar</code>, although instead of working only on the outermost layer of a nested structure, it maps recursively through outer layers and calls <code>similar</code> on the innermost array-like object only. Type <code>T</code> is the new number element type <a href="interface.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a>, if it is not given the element type of <code>a</code> is retained. The <code>dims</code> argument can be given for non-nested allocation and is forwarded to the function <code>similar</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.base_manifold" href="#ManifoldsBase.base_manifold"><code>ManifoldsBase.base_manifold</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">base_manifold(M::Manifold, depth = Val(-1))</code></pre><p>Return the internally stored <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> for decorated manifold <code>M</code> and the base manifold for vector bundles or power manifolds. The optional parameter <code>depth</code> can be used to remove only the first <code>depth</code> many decorators and return the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> from that level, whether its decorated or not. Any negative value deactivates this depth limit.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}" href="#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>ManifoldsBase.check_manifold_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_manifold_point(M::Manifold, p; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Return <code>nothing</code> when <code>p</code> is a point on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Otherwise, return an error with description why the point does not belong to manifold <code>M</code>.</p><p>By default, <code>check_manifold_point</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for a point not deriving from the <a href="interface.html#ManifoldsBase.MPoint"><code>MPoint</code></a> type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.check_tangent_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">check_tangent_vector(M::Manifold, p, X; kwargs...) -&gt; Union{Nothing,String}</code></pre><p>Check whether <code>X</code> is a valid tangent vector in the tangent space of <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. An implementation should first call <a href="interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point(M, p; kwargs...)</code></a> and then validate <code>X</code>. If it is not a tangent vector, an error string should be returned.</p><p>By default, <code>check_tangent_vector</code> returns <code>nothing</code>, i.e. if no checks are implemented, the assumption is to be optimistic for tangent vectors not deriving from the <a href="interface.html#ManifoldsBase.TVector"><code>TVector</code></a> type.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.distance-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.distance-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.distance</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">distance(M::Manifold, p, q)</code></pre><p>Shortest distance between the points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.exp!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.exp!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">exp!(M::Manifold, q, p, X)
exp!(M::Manifold, q, p, X, t::Real = 1)</code></pre><p>Compute the exponential map of tangent vector <code>X</code>, optionally scaled by <code>t</code>,  at point <code>p</code> from manifold the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. The result is saved to <code>q</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">geodesic(M::Manifold, p, X) -&gt; Function</code></pre><p>Get the geodesic with initial point <code>p</code> and velocity <code>X</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.  The geodesic is the curve of constant velocity that is locally distance-minimizing.  This function returns a function of (time) <code>t</code>.</p><pre><code class="language-none">geodesic(M::Manifold, x, v, t::Real)
geodesic(M::Manifold, x, v, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the geodesic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.hat-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.hat-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.hat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">hat(M::Manifold, p, Xⁱ)</code></pre><p>Given a basis <span>$e_i$</span> on the tangent space at a point <code>p</code> and tangent component vector <span>$X^i$</span>, compute the equivalent vector representation <span>$X=X^i e_i$</span>, where Einstein summation notation is used:</p><div>\[∧ : X^i ↦ X^i e_i\]</div><p>For array manifolds, this converts a vector representation of the tangent vector to an array representation. The <a href="interface.html#ManifoldsBase.vee-Tuple{Manifold,Any,Any}"><code>vee</code></a> map is the <code>hat</code> map&#39;s inverse.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.injectivity_radius-Tuple{Manifold}" href="#ManifoldsBase.injectivity_radius-Tuple{Manifold}"><code>ManifoldsBase.injectivity_radius</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">injectivity_radius(M::Manifold, p)</code></pre><p>Return the distance <span>$d$</span> such that <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp(M, p, X)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse).</p><pre><code class="language-none">injectivity_radius(M::Manifold)</code></pre><p>Infimum of the injectivity radius of all manifold points.</p><pre><code class="language-none">injectivity_radius(M::Manifold[, x], method::AbstractRetractionMethod)
injectivity_radius(M::Manifold, x, method::AbstractRetractionMethod)</code></pre><p>Distance <span>$d$</span> such that <a href="interface.html#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>retract(M, p, X, method)</code></a> is injective for all tangent vectors shorter than <span>$d$</span> (i.e. has an inverse) for point <code>p</code> if provided or all manifold points otherwise.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.inner</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inner(M::Manifold, p, X, Y)</code></pre><p>Compute the inner product of tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.inverse_retract!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.inverse_retract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_retract!(M::Manifold, X, p, q[, method::AbstractInverseRetractionMethod])</code></pre><p>Compute the inverse retraction, a cheaper, approximate version of the <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map), of points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Result is saved to <code>X</code>.</p><p>Inverse retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.LogarithmicInverseRetraction"><code>LogarithmicInverseRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.inverse_retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">inverse_retract(M::Manifold, x, y)
inverse_retract(M::Manifold, x, y, method::AbstractInverseRetractionMethod</code></pre><p>Compute the inverse retraction, a cheaper, approximate version of the <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map), of points <code>p</code> and <code>q</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>Inverse retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.LogarithmicInverseRetraction"><code>LogarithmicInverseRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_manifold_point" href="#ManifoldsBase.is_manifold_point"><code>ManifoldsBase.is_manifold_point</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_manifold_point(M::Manifold, p, throw_error = false; kwargs...)</code></pre><p>Return whether <code>p</code> is a valid point on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="interface.html#ManifoldsBase.check_manifold_point-Tuple{Manifold,Any}"><code>check_manifold_point(M, p; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.is_tangent_vector" href="#ManifoldsBase.is_tangent_vector"><code>ManifoldsBase.is_tangent_vector</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_tangent_vector(M::Manifold, p, X, throw_error = false; kwargs...)</code></pre><p>Return whether <code>X</code> is a valid tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. Returns either <code>true</code> or <code>false</code>.</p><p>If <code>throw_error</code> is <code>false</code>, the function returns either <code>true</code> or <code>false</code>. If <code>throw_error</code> is <code>true</code>, the function either returns <code>true</code> or throws an error. By default the function calls <a href="interface.html#ManifoldsBase.check_tangent_vector-Tuple{Manifold,Any,Any}"><code>check_tangent_vector(M, p, X; kwargs...)</code></a> and checks whether the returned value is <code>nothing</code> or an error.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.log!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.log!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">log!(M::Manifold, X, p, q)</code></pre><p>Compute the logarithmic map of point <code>q</code> at base point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. THe result is saved to <code>X</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.manifold_dimension-Tuple{Manifold}" href="#ManifoldsBase.manifold_dimension-Tuple{Manifold}"><code>ManifoldsBase.manifold_dimension</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">manifold_dimension(M::Manifold)</code></pre><p>The dimension <span>$n=\dim_{\mathcal M}$</span> of real space <span>$\mathbb R^n$</span> to which the neighborhood of each point of the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> is homeomorphic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.number_eltype-Tuple{Any}" href="#ManifoldsBase.number_eltype-Tuple{Any}"><code>ManifoldsBase.number_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">number_eltype(x)</code></pre><p>Numeric element type of the a nested representation of a point or a vector. To be used in conjuntion with <a href="interface.html#ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}"><code>allocate</code></a> or <a href="interface.html#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>allocate_result</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project_point!-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.project_point!-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.project_point!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_point!(M::Manifold, q, p)</code></pre><p>Project point <code>p</code> from the ambient space onto the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. The point <code>q</code> is overwritten by the projection. The function works only for selected embedded manifolds and is <em>not</em> required to return the closest point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project_point-Tuple{Manifold,Any}" href="#ManifoldsBase.project_point-Tuple{Manifold,Any}"><code>ManifoldsBase.project_point</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_point(M::Manifold, p)</code></pre><p>Project point <code>p</code>from the ambient space onto the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. The function works only for selected embedded manifolds and is <em>not</em> required to return the closest point.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project_tangent!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.project_tangent!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.project_tangent!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_tangent!(M::Manifold, Y, p, X)</code></pre><p>Project ambient space representation of a vector <code>X</code> to a tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>. The result is saved in vector <code>Y</code>.</p><p>The function works only for selected embedded manifolds and is <em>not</em> required to return the closest vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.project_tangent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">project_tangent(M::Manifold, p, X)</code></pre><p>Project ambient space representation of a vector <code>X</code> to a tangent vector at point <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>The function works only for selected embedded manifolds and is <em>not</em> required to return the closest vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.representation_size-Tuple{Manifold}" href="#ManifoldsBase.representation_size-Tuple{Manifold}"><code>ManifoldsBase.representation_size</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">representation_size(M::Manifold)</code></pre><p>The size of an array representing a point on <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.retract!-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.retract!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">retract!(M::Manifold, q, p, X)
retract!(M::Manifold, q, p, X, t::Real=1)
retract!(M::Manifold, q, p, X, method::AbstractRetractionMethod)
retract!(M::Manifold, q, p, X, t::Real=1, method::AbstractRetractionMethod)</code></pre><p>Compute a retraction, a cheaper, approximate version of the <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential map, from <code>p</code> into direction <code>X</code>, scaled by <code>t</code>, on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> manifold <code>M</code>. Result is saved to <code>q</code>.</p><p>Retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.retract-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.retract-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.retract</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">retract(M::Manifold, p, X)
retract(M::Manifold, p, X, t::Real=1)
retract(M::Manifold, p, X, method::AbstractRetractionMethod)
retract(M::Manifold, p, X, t::Real=1, method::AbstractRetractionMethod)</code></pre><p>Compute a retraction, a cheaper, approximate version of the <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a>onential map, from <code>p</code> into direction <code>X</code>, scaled by <code>t</code>, on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>.</p><p>Retraction method can be specified by the last argument, defaulting to <a href="interface.html#ManifoldsBase.ExponentialRetraction"><code>ExponentialRetraction</code></a>. See the documentation of respective manifolds for available methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.shortest_geodesic-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.shortest_geodesic</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">shortest_geodesic(M::Manifold, p, q) -&gt; Function</code></pre><p>Get a <a href="interface.html#ManifoldsBase.geodesic-Tuple{Manifold,Any,Any}"><code>geodesic</code></a> <span>$\gamma_{p,q}(t)$</span> whose length is the shortest path between the points <code>p</code>and <code>q</code>, where <span>$\gamma_{p,q}(0)=p$</span> and <span>$\gamma_{p,q}(1)=q$</span>. When there are multiple shortest geodesics, there is no guarantee which will be returned.</p><p>This function returns a function of time, which may be a <code>Real</code> or an <code>AbstractVector</code>.</p><pre><code class="language-none">shortest_geodesic(M::Manifold, p, q, t::Real)
shortest_geodesic(M::Manifold, p, q, T::AbstractVector) -&gt; AbstractVector</code></pre><p>Return the point at time <code>t</code> or points at times <code>t</code> in <code>T</code> along the shortest geodesic.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_along!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_along!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_along!(M::Manifold, Y, p, X, c)
vector_transport_along!(M::Manifold, Y, p, X, c, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from a point <code>p</code> along the curve <code>c</code> such that <code>c(0)</code> is equal to <code>p</code> to the point <code>c(1)</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>. The result is saved to <code>Y</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_along-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_along</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_along(M::Manifold, p, X, c)
vector_transport_along(M::Manifold, p, X, c, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from a point <code>p</code> along the curve <code>c</code> such that <code>c(0)</code> is equal to <code>p</code> to the point <code>c(1)</code> using the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_direction!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_direction!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_direction!(M::Manifold, Y, p, X, d)
vector_transport_direction!(M::Manifold, Y, p, X, d, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from a point <code>p</code> in the direction indicated by the tangent vector <code>d</code> at point <code>p</code>. The result is saved to <code>Y</code>. By default, <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> and <a href="interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_direction-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_direction</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_direction(M::Manifold, p, X, d)
vector_transport_direction(M::Manifold, p, X, d, method::AbstractVectorTransportMethod)</code></pre><p>Transport a vector <code>X</code> from a point <code>p</code> in the direction indicated by the tangent vector <code>d</code> at point <code>p</code>. By default, <a href="interface.html#Base.exp-Tuple{Manifold,Any,Any}"><code>exp</code></a> and <a href="interface.html#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}"><code>vector_transport_to!</code></a> are used with the <code>method</code>, which defaults to <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}" href="#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any,ProjectionTransport}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, Y, p, X, q, method::ProjectionTransport)</code></pre><p>Transport a vector <code>X</code> from the tangent space at <code>p</code> on a <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> by interpreting it as an element of the embedding and then projecting it onto the tangent space at <code>q</code>. This method requires <a href="interface.html#ManifoldsBase.project_tangent-Tuple{Manifold,Any,Any}"><code>project_tangent</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}" href="#ManifoldsBase.vector_transport_to!-Tuple{Manifold,Any,Any,Any,Any}"><code>ManifoldsBase.vector_transport_to!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to!(M::Manifold, Y, p, X, q)
vector_transport_to!(M::Manifold, Y, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Compute the vector transport of vector <code>X</code> at point <code>p</code> to point <code>q</code>. The result is saved to <code>Y</code>. By default, the <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> is <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}" href="#ManifoldsBase.vector_transport_to-Tuple{Manifold,Any,Any,Any}"><code>ManifoldsBase.vector_transport_to</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vector_transport_to(M::Manifold, p, X, q)
vector_transport_to(M::Manifold, p, X, q, method::AbstractVectorTransportMethod)</code></pre><p>Compute the vector transport of vector <code>X</code> at point <code>p</code> to point <code>q</code>. By default, the <a href="interface.html#ManifoldsBase.AbstractVectorTransportMethod"><code>AbstractVectorTransportMethod</code></a> <code>method</code> is <a href="interface.html#ManifoldsBase.ParallelTransport"><code>ParallelTransport</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.vee-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.vee-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.vee</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">vee(M::Manifold, p, X)</code></pre><p>Given a basis <span>$e_i$</span> on the tangent space at a point <code>p</code> and tangent vector <code>X</code>, compute the vector components <span>$X^i$</span>, such that <span>$X = X^i e_i$</span>, where Einstein summation notation is used:</p><div>\[\vee : X^i e_i ↦ X^i\]</div><p>For array manifolds, this converts an array representation of the tangent vector to a vector representation. The <a href="interface.html#ManifoldsBase.hat-Tuple{Manifold,Any,Any}"><code>hat</code></a> map is the <code>vee</code> map&#39;s inverse.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_tangent_vector!-Tuple{Manifold,Any,Any}" href="#ManifoldsBase.zero_tangent_vector!-Tuple{Manifold,Any,Any}"><code>ManifoldsBase.zero_tangent_vector!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_tangent_vector!(M::Manifold, X, p)</code></pre><p>Save to <code>X</code> a vector such that retracting <code>X</code> to the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> at <code>p</code> produces <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.zero_tangent_vector-Tuple{Manifold,Any}" href="#ManifoldsBase.zero_tangent_vector-Tuple{Manifold,Any}"><code>ManifoldsBase.zero_tangent_vector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_tangent_vector(M::Manifold, p)</code></pre><p>Return the tangent vector from the tangent space at <code>p</code> on the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code>, that represents the zero vector, i.e. such that a retraction at <code>p</code> produces <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractEstimationMethod" href="#ManifoldsBase.AbstractEstimationMethod"><code>ManifoldsBase.AbstractEstimationMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractEstimationMethod</code></pre><p>Abstract type for defining statistical estimation methods.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.AbstractVectorTransportMethod" href="#ManifoldsBase.AbstractVectorTransportMethod"><code>ManifoldsBase.AbstractVectorTransportMethod</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">AbstractVectorTransportMethod</code></pre><p>Abstract type for methods for transporting vectors.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.OutOfInjectivityRadiusError" href="#ManifoldsBase.OutOfInjectivityRadiusError"><code>ManifoldsBase.OutOfInjectivityRadiusError</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">OutOfInjectivityRadiusError</code></pre><p>An error thrown when a function (for example <a href="interface.html#Base.log-Tuple{Manifold,Any,Any}"><code>log</code></a>arithmic map or <a href="interface.html#ManifoldsBase.inverse_retract-Tuple{Manifold,Any,Any}"><code>inverse_retract</code></a>) is given arguments outside of its <a href="interface.html#ManifoldsBase.injectivity_radius-Tuple{Manifold}"><code>injectivity_radius</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.angle-Tuple{Manifold,Any,Any,Any}" href="#Base.angle-Tuple{Manifold,Any,Any,Any}"><code>Base.angle</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">angle(M::Manifold, p, X, Y)</code></pre><p>Compute the angle between tangent vectors <code>X</code> and <code>Y</code> at point <code>p</code> from the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> with respect to the inner product from <a href="interface.html#ManifoldsBase.inner-Tuple{Manifold,Any,Any,Any}"><code>inner</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}" href="#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>ManifoldsBase.allocate_result</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allocate_result(M::Manifold, f, x...)</code></pre><p>Allocate an array for the result of function <code>f</code> on <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> and arguments <code>x...</code> for implementing the non-modifying operation using the modifying operation.</p><p>Usefulness of passing a function is demonstrated by methods that allocate results of musical isomorphisms.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N" href="#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N"><code>ManifoldsBase.allocate_result_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">allocate_result_type(M::Manifold, f, args::NTuple{N,Any}) where N</code></pre><p>Return type of element of the array that will represent the result of function <code>f</code> and the <a href="interface.html#ManifoldsBase.Manifold"><code>Manifold</code></a> <code>M</code> on given arguments <code>args</code> (passed as a tuple).</p></div></section></article><h2 id="DefaultManifold-1"><a class="docs-heading-anchor" href="#DefaultManifold-1"><code>DefaultManifold</code></a><a class="docs-heading-anchor-permalink" href="#DefaultManifold-1" title="Permalink"></a></h2><p><code>DefaultManifold</code> is a simplified version of <a href="manifolds/euclidean.html#Manifolds.Euclidean"><code>Euclidean</code></a> and demonstrates a basic interface implementation.</p><article class="docstring"><header><a class="docstring-binding" id="ManifoldsBase.DefaultManifold" href="#ManifoldsBase.DefaultManifold"><code>ManifoldsBase.DefaultManifold</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">DefaultManifold &lt;: Manifold</code></pre><p>This default manifold illustrates the main features of the interface and provides a skeleton to build one&#39;s own manifold. It is a simplified/shortened variant of <code>Euclidean</code> from <code>Manifolds.jl</code>.</p><p>This manifold further illustrates how to type your manifold points and tangent vectors. Note that the interface does not require this, but it might be handy in debugging and educative situations to verify correctness of involved variabes.</p></div></section></article><h2 id="Allocation-1"><a class="docs-heading-anchor" href="#Allocation-1">Allocation</a><a class="docs-heading-anchor-permalink" href="#Allocation-1" title="Permalink"></a></h2><p>Non-mutating functions in <code>Manifolds.jl</code> are typically implemented using mutating variants. Allocation of new points is performed using a custom mechanism that relies on the following functions:</p><ul><li><a href="interface.html#ManifoldsBase.allocate-Tuple{Any,Vararg{Any,N} where N}"><code>allocate</code></a> that allocates a new point or vector similar to the given one. This function behaves like <code>similar</code> for simple representations of points and vectors (for example <code>Array{Float64}</code>). For more complex types, such as nested representations of <a href="manifolds/power.html#Manifolds.PowerManifold"><code>PowerManifold</code></a> (see <a href="manifolds/power.html#Manifolds.NestedPowerRepresentation"><code>NestedPowerRepresentation</code></a>), <a href="manifolds/vector_bundle.html#Manifolds.FVector"><code>FVector</code></a> types, checked types like <a href="manifolds/array.html#ManifoldsBase.ArrayMPoint"><code>ArrayMPoint</code></a> and more it operates differently. While <code>similar</code> only concerns itself with the higher level of nested structures, <code>allocate</code> maps itself through all levels of nesting until a simple array of numbers is reached and then calls <code>similar</code>. The difference can be most easily seen in the following example:</li></ul><pre><code class="language-julia">julia&gt; x = similar([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 #undef
 #undef

julia&gt; y = Manifolds.allocate([[1.0], [2.0]])
2-element Array{Array{Float64,1},1}:
 [6.90031725726027e-310]
 [6.9003678131654e-310]

julia&gt; x[1]
ERROR: UndefRefError: access to undefined reference
Stacktrace:
 [1] getindex(::Array{Array{Float64,1},1}, ::Int64) at ./array.jl:744
 [2] top-level scope at REPL[12]:1

julia&gt; y[1]
1-element Array{Float64,1}:
 6.90031725726027e-310</code></pre><ul><li><a href="interface.html#ManifoldsBase.allocate_result-Tuple{Manifold,Any,Vararg{Any,N} where N}"><code>allocate_result</code></a> allocates a result of a particular function (for example [<code>exp</code>], [<code>flat</code>], etc.) on a particular manifold with particular arguments. It takes into account the possibility that different arguments may have different numeric <a href="interface.html#ManifoldsBase.number_eltype-Tuple{Any}"><code>number_eltype</code></a> types thorough the <a href="interface.html#ManifoldsBase.allocate_result_type-Union{Tuple{N}, Tuple{Manifold,Any,Tuple{Vararg{Any,N}}}} where N"><code>ManifoldsBase.allocate_result_type</code></a> function.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="index.html">« Home</a><a class="docs-footer-nextpage" href="manifolds/choleskyspace.html">Cholesky space »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 6 March 2020 21:38">Friday 6 March 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
